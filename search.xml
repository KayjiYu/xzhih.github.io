<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>给你的Nginx加个防火墙</title>
      <link href="/ngx-lua-waf/"/>
      <url>/ngx-lua-waf/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前几天有个朋友跟我说，他的一个 WordPress 站经常访问慢。</p><p>帮他看了一下日志，发现整天被人扫网站目录的什么 phpmyadmin 或者 SQL 文件，要不就是被 CC，刚开始我还以为是主机商帮扫漏洞之类的，后来发现实在是太密集了，看来不是。</p><p>我就笑了，他那破站有啥值得扫的，不过 CC 的话倒也不奇怪，有些人就是爱搞这些无聊的事情。</p><p>然后他又说，用的是腾讯云的1元小鸡，刚开始非常流畅的啊，不至于现在这么惨吧。</p><p>我看了一下真搞笑，本身机器性能就不行了，还不做静态化，被 CC 的时候负载自然上去了，而且小鸡才 1M 的带宽，不慢才怪。</p><p>他说他的站就写写笔记或者转载一些文章，也不是什么重要的东西，但是整天被搞也是不太爽，怎么弄才能解决。。。</p><p>我想也是，虽然东西是垃圾，但好歹还是在用的，不过嘛解决是不可能解决的，只要别人能访问，你就会遇到这样那样的傻逼，不过改善还是可以啦。既然主机商的各种安全套餐咱们用不起，那就用一些大佬写好的方案吧。</p><p>找了一下，发现 ngx_lua_waf 是个不错的方案，但是太久不更新了，而且代码我看不懂，猝</p><p>最后找到 oneinstack 一键包内置的 ngx_lua_waf，基于之前的代码，不过重构 了，这下我能看懂了，以后要修改也能简单一些</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://github.com/xzhih/ngx_lua_waf" target="_blank" rel="noopener">ngx_lua_waf</a> 是一个高性能的轻量级 web 应用防火墙，基于 lua-nginx-module。</p><p><img src="https://pic.zhih.me/blog/posts/ngx-lua-waf/waf.jpg" alt="ngx_lua_waf"></p><p>它具有以下功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">防止sql注入，本地包含，部分溢出，fuzzing测试，xss,SSRF等web攻击</span><br><span class="line">防止svn/备份之类文件泄漏</span><br><span class="line">防止ApacheBench之类压力测试工具的攻击</span><br><span class="line">屏蔽常见的扫描黑客工具，扫描器</span><br><span class="line">屏蔽异常的网络请求</span><br><span class="line">屏蔽图片附件类目录php执行权限</span><br><span class="line">防止webshell上传</span><br></pre></td></tr></table></figure><p>经过 <a href="https://github.com/unixhot/waf" target="_blank" rel="noopener">unixhot</a> 的修改和重构，拥有了以下功能：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">支持IP白名单和黑名单功能，直接将黑名单的IP访问拒绝</span><br><span class="line">支持<span class="built_in">URL</span>白名单，将不需要过滤的<span class="built_in">URL</span>进行定义</span><br><span class="line">支持User-Agent的过滤，匹配自定义规则中的条目，然后进行处理（返回<span class="number">403</span>）</span><br><span class="line">支持CC攻击防护，单个<span class="built_in">URL</span>指定时间的访问次数，超过设定值，直接返回<span class="number">403</span></span><br><span class="line">支持Cookie过滤，匹配自定义规则中的条目，然后进行处理（返回<span class="number">403</span>）</span><br><span class="line">支持<span class="built_in">URL</span>过滤，匹配自定义规则中的条目，如果用户请求的<span class="built_in">URL</span>包含这些，返回<span class="number">403</span></span><br><span class="line">支持<span class="built_in">URL</span>参数过滤，原理同上</span><br><span class="line">支持日志记录，将所有拒绝的操作，记录到日志中去</span><br><span class="line">日志记录为JSON格式，便于日志分析，例如使用ELKStack进行攻击日志收集、存储、搜索和展示</span><br></pre></td></tr></table></figure><p>这些功能刚好能满足我朋友的需求</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装起来也是相当容易，说白了就是给 nginx 增加 ngx_devel_kit、lua-nginx-module 这两个模块，然后再修改 nginx 配置来运行 ngx_lua_waf。</p><h3 id="一键安装"><a href="#一键安装" class="headerlink" title="一键安装"></a>一键安装</h3><p>一键命令我已经给你们准备好了，一键命令会编译 nginx-1.15.6，编译的详细模块可以看我的这篇帖子 <a href="https://zhih.me/make-your-website-support-tls1-3">https://zhih.me/make-your-website-support-tls1-3</a> ，当然你也可以直接看脚本的代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -kfsSl https://raw.githubusercontent.com/xzhih/nginx-compile/master/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><h4 id="下载-ngx-lua-waf-防火墙的各种依赖及模块"><a href="#下载-ngx-lua-waf-防火墙的各种依赖及模块" class="headerlink" title="下载 ngx_lua_waf 防火墙的各种依赖及模块"></a>下载 ngx_lua_waf 防火墙的各种依赖及模块</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/</span><br><span class="line">wget https://github.com/openresty/luajit2/archive/v2.1-20181029.tar.gz</span><br><span class="line">tar xzvf v2.1-20181029.tar.gz</span><br><span class="line">mv luajit2-2.1-20181029 luajit-2.1</span><br><span class="line"></span><br><span class="line">wget https://github.com/openresty/lua-cjson/archive/2.1.0.6.tar.gz</span><br><span class="line">tar xzvf 2.1.0.6.tar.gz</span><br><span class="line">mv lua-cjson-2.1.0.6 lua-cjson</span><br><span class="line"></span><br><span class="line">wget https://github.com/simplresty/ngx_devel_kit/archive/v0.3.1rc1.tar.gz</span><br><span class="line">tar xzvf v0.3.1rc1.tar.gz</span><br><span class="line">mv ngx_devel_kit-0.3.1rc1 ngx_devel_kit</span><br><span class="line"></span><br><span class="line">wget https://github.com/openresty/lua-nginx-module/archive/v0.10.13.tar.gz</span><br><span class="line">tar xzvf v0.10.13.tar.gz  </span><br><span class="line">mv lua-nginx-module-0.10.13 lua-nginx-module</span><br></pre></td></tr></table></figure><h4 id="编译安装-luajit"><a href="#编译安装-luajit" class="headerlink" title="编译安装 luajit"></a>编译安装 luajit</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> luajit-2.1</span><br><span class="line">make -j2 &amp;&amp; make install</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'/usr/local/lib'</span> &gt;&gt; /etc/ld.so.conf.d/local.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><h4 id="编译安装-lua-cjson"><a href="#编译安装-lua-cjson" class="headerlink" title="编译安装 lua-cjson"></a>编译安装 lua-cjson</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/lua-cjson</span><br><span class="line"><span class="built_in">export</span> LUA_INCLUDE_DIR=/usr/<span class="built_in">local</span>/include/luajit-2.1 </span><br><span class="line">make -j2 &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="设置-LUAJIT-环境变量"><a href="#设置-LUAJIT-环境变量" class="headerlink" title="设置 LUAJIT 环境变量"></a>设置 LUAJIT 环境变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LUAJIT_LIB=/usr/<span class="built_in">local</span>/lib</span><br><span class="line"><span class="built_in">export</span> LUAJIT_INC=/usr/<span class="built_in">local</span>/include/luajit-2.1</span><br></pre></td></tr></table></figure><h4 id="编译-nginx-的时候加上以下两个模块"><a href="#编译-nginx-的时候加上以下两个模块" class="headerlink" title="编译 nginx 的时候加上以下两个模块"></a>编译 nginx 的时候加上以下两个模块</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--add-module=../lua-nginx-module</span><br><span class="line">--add-module=../ngx_devel_kit</span><br></pre></td></tr></table></figure><h4 id="下载配置-ngx-lua-waf"><a href="#下载配置-ngx-lua-waf" class="headerlink" title="下载配置 ngx_lua_waf"></a>下载配置 ngx_lua_waf</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/conf/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/xzhih/ngx_lua_waf.git waf </span><br><span class="line"></span><br><span class="line">cat &gt; /usr/<span class="built_in">local</span>/nginx/conf/waf.conf &lt;&lt; EOF</span><br><span class="line">lua_shared_dict <span class="built_in">limit</span> 20m;</span><br><span class="line">lua_package_path <span class="string">"/usr/local/nginx/conf/waf/?.lua"</span>;</span><br><span class="line">init_by_lua_file <span class="string">"/usr/local/nginx/conf/waf/init.lua"</span>;</span><br><span class="line">access_by_lua_file <span class="string">"/usr/local/nginx/conf/waf/access.lua"</span>;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/nginx/logs/waf </span><br><span class="line">chown www-data:www-data /usr/<span class="built_in">local</span>/nginx/logs/waf</span><br></pre></td></tr></table></figure><p>你可以在 <code>/usr/local/nginx/logs/waf</code> 找到防火墙日志</p><h4 id="在-nginx-conf-里-include-waf-conf"><a href="#在-nginx-conf-里-include-waf-conf" class="headerlink" title="在 nginx.conf 里 include waf.conf"></a>在 <code>nginx.conf</code> 里 include <code>waf.conf</code></h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">include</span> waf.conf;</span></span><br></pre></td></tr></table></figure><p>启动 nginx 并访问 http://你的IP/?a=a.sql</p><p>就可以看到防火墙提示了</p><h2 id="Copyright"><a href="#Copyright" class="headerlink" title="Copyright"></a>Copyright</h2><p><a href="https://github.com/lj2007331/ngx_lua_waf" target="_blank" rel="noopener">https://github.com/lj2007331/ngx_lua_waf</a></p><p><a href="https://github.com/loveshell/ngx_lua_waf" target="_blank" rel="noopener">https://github.com/loveshell/ngx_lua_waf</a></p><p><a href="https://github.com/unixhot/waf" target="_blank" rel="noopener">https://github.com/unixhot/waf</a></p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> web优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用acme.sh获取免费SSL证书</title>
      <link href="/acme-sh-guide/"/>
      <url>/acme-sh-guide/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="noopener">acme.sh</a> 是一个 ACME(自动化证书管理环境) 脚本，可以从 letsencrypt 生成免费的证书。</p><p>本来这个教程是写在 <a href="https://zhih.me/make-your-website-support-tls1-3/">编译Nginx支持TLS1.3</a> 那篇帖子里的，后来感觉还是单独拿出来比较好，即能让那篇教程更简洁，也能更方便的让需要的人看到这个教程。</p><h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install cron socat -y</span><br></pre></td></tr></table></figure><h2 id="获取-acme-sh"><a href="#获取-acme-sh" class="headerlink" title="获取 acme.sh"></a>获取 acme.sh</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl  https://get.acme.sh | sh</span><br></pre></td></tr></table></figure><p>重启终端，如果你使用 zsh 可以这样 <code>source ~/.zshrc</code></p><h2 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h2><p>使用 http 方式验证域名，需要先搭建 HTTP 站点，接下来指定域名、指定站点目录，开始签发</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">acme.sh --issue -d onmp.ooo \</span><br><span class="line">          --webroot /wwwroot/onmp.ooo/ \</span><br><span class="line">          --keylength ec-256 \</span><br><span class="line">          --nginx</span><br></pre></td></tr></table></figure><p>如果是多域名，可以使用 -d 参数添加，如：<code>-d www.onmp.ooo</code><br><code>--keylength ec-256</code> 是签发 ECC 类型的证书，它的安全性更高，删除则使用默认的 RSA 证书</p><h2 id="复制证书"><a href="#复制证书" class="headerlink" title="复制证书"></a>复制证书</h2><p>证书已经签发了，不过默认是保存在 <code>~/.acme.sh/</code> 里</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">acme.sh --ecc --installcert -d onmp.ooo \</span><br><span class="line">          --key-file /usr/<span class="built_in">local</span>/nginx/conf/ssl/onmp.ooo.key \</span><br><span class="line">          --fullchain-file /usr/<span class="built_in">local</span>/nginx/conf/ssl/onmp.ooo.cer \</span><br><span class="line">          --reloadcmd <span class="string">"service nginx force-reload"</span></span><br></pre></td></tr></table></figure><p>指定域名，指定证书保存目录，我这里设置在 <code>/usr/local/nginx/conf/ssl/</code>，指定 Nginx 重载命令，如果签发的不是 ECC 证书，把 <code>--ecc</code> 参数去掉</p><p>这样使用 acme.sh 就完成了证书的签发，如果证书快要过期了，脚本会自动更新证书</p><p>脚本自动更新，可以使用以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">acme.sh --upgrade --auto-upgrade</span><br></pre></td></tr></table></figure><h2 id="证书安装"><a href="#证书安装" class="headerlink" title="证书安装"></a>证书安装</h2><p>证书已经获取并且可以自动更新了，具体安装方法看 <a href="https://zhih.me/make-your-website-support-tls1-3/">编译Nginx支持TLS1.3</a></p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> https </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编译Nginx支持TLS1.3</title>
      <link href="/make-your-website-support-tls1-3/"/>
      <url>/make-your-website-support-tls1-3/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>TLS1.2 发布于 2008 年 8 月，至今正好有 10 年，随着互联网安全越来越受到重视，新协议 TLS1.3 呼之欲出。值得一提的是，从第一份草案编写至今，已经有几年时间了，截止这篇文章编写，已经是第 28 份草案。在最近的 Chrome 版本更新中也逐步对 TLS1.3 进行支持，Chrome 65 开始默认开启 draft 23、Chrome 68 开始支持 draft 28</p><blockquote><p>更新：TLS 1.3 标准已于 2018 年 8 月正式发布为 <a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">RFC 8446 </a>，距 TLS1.2 发布正好 10 周年</p></blockquote><p>TLS1.3 对于 TLS1.2 有重大改写，既提高了安全性又提高了速度，以至于有争议称，应该把它叫做 TLS2.0</p><p>关于 TLS1.3 的科普可以看下面的页面</p><p><a href="https://wiki.openssl.org/index.php/TLS1.3" target="_blank" rel="noopener">https://wiki.openssl.org/index.php/TLS1.3</a><br><a href="https://zhuanlan.zhihu.com/p/28850798" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28850798</a></p><p>之前我也写过 Nginx 的 https 的配置 <a href="https://zhih.me/nginx-http2-https/">https://zhih.me/nginx-http2-https/</a> ，当时是使用 TLS1.2 的</p><p>碰巧前几天发现 <code>.ooo</code> 可以免费用 1 年，就撸了一个 <code>onmp.ooo</code> 来做为我 onmp 项目的页面，把它搭在 4 刀年付的 virmach 上，顺便测试 TLS1.3</p><h2 id="一键安装"><a href="#一键安装" class="headerlink" title="一键安装"></a>一键安装</h2><p>最近更新支持防火墙功能，详情可以看 <a href="https://zhih.me/ngx-lua-waf/">https://zhih.me/ngx-lua-waf/</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -kfsSl https://raw.githubusercontent.com/xzhih/nginx-compile/master/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我这里用的系统是 Debian 8</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install git gcc make build-essential -y</span><br></pre></td></tr></table></figure><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>我们把源码全都放在一个地方，方便使用，创建 nginx 的运行用户 www-data</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf /usr/src/</span><br><span class="line">mkdir -p /usr/src/</span><br><span class="line">mkdir -p /var/<span class="built_in">log</span>/nginx/</span><br><span class="line">useradd -s /sbin/nologin -M www-data</span><br></pre></td></tr></table></figure><p><strong>克隆 OpenSSL</strong></p><p>这里用的是 1.1.1 稳定版的源码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src</span><br><span class="line">wget https://github.com/openssl/openssl/archive/OpenSSL_1_1_1.tar.gz </span><br><span class="line">tar xzvf OpenSSL_1_1_1.tar.gz</span><br><span class="line">mv openssl-OpenSSL_1_1_1 openssl</span><br></pre></td></tr></table></figure><p><strong>下载 Nginx 的源码</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/</span><br><span class="line">wget https://nginx.org/download/nginx-1.15.6.tar.gz</span><br><span class="line">tar zxf ./nginx-1.15.6.tar.gz </span><br><span class="line">mv nginx-1.15.6 nginx</span><br></pre></td></tr></table></figure><p><strong>克隆 zlib</strong></p><p>开启 gzip 要用到 zlib 库，这里使用的是 Cloudflare 优化的版本，比原版具有更高的压缩性能</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/cloudflare/zlib.git zlib</span><br><span class="line"><span class="built_in">cd</span> zlib</span><br><span class="line">make -f Makefile.in distclean</span><br></pre></td></tr></table></figure><p><strong>克隆 Brotli</strong></p><p>就像 gzip 一样，Brotli 也是一种压缩算法，它是由谷歌开发的一个更适合文本压缩的算法，因为它使用了字典，所以有更好的压缩比。</p><p>现在主流浏览器都已经支持 Brotli 了，而且也能与 gzip 共存，如果浏览器支持 Brotli 就会优先使用，所以可以放心兼容性，可以在这里看到支持的数据 <a href="https://caniuse.com/#search=Brotli" target="_blank" rel="noopener">https://caniuse.com/#search=Brotli</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/</span><br><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/google/ngx_brotli.git</span><br></pre></td></tr></table></figure><p>我给 nginx 默认配置的 Brotli 压缩等级为 6 级，这对于动态内容比较友好，如果你是像我现在这个博客一样是静态化的，那么建议开启 11 级压缩，这样可以获得最好的体验</p><p><strong>下载 PCRE</strong></p><p>nginx rewrite 模块需要 pcre 库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/</span><br><span class="line">wget https://ftp.pcre.org/pub/pcre/pcre-8.42.tar.gz</span><br><span class="line">tar zxf ./pcre-8.42.tar.gz</span><br></pre></td></tr></table></figure><h3 id="给-OpenSSL-打补丁"><a href="#给-OpenSSL-打补丁" class="headerlink" title="给 OpenSSL 打补丁"></a>给 OpenSSL 打补丁</h3><p>补丁来自：<a href="https://github.com/hakasenyang/openssl-patch" target="_blank" rel="noopener">https://github.com/hakasenyang/openssl-patch</a></p><p>此补丁的目的是让 OpenSSL 支持 TLS1.3 的 23,26,28 草案，以及 Final 版标准</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hakasenyang/openssl-patch.git</span><br><span class="line"><span class="built_in">cd</span> /usr/src/openssl </span><br><span class="line">patch -p1 &lt; ../openssl-patch/openssl-equal-1.1.1_ciphers.patch</span><br><span class="line">patch -p1 &lt; ../openssl-patch/openssl-1.1.1-chacha_draft.patch</span><br></pre></td></tr></table></figure><h3 id="给-Nginx-打补丁"><a href="#给-Nginx-打补丁" class="headerlink" title="给 Nginx 打补丁"></a>给 Nginx 打补丁</h3><p>补丁来自：<a href="https://github.com/kn007/patch" target="_blank" rel="noopener">https://github.com/kn007/patch</a></p><p>nginx 补丁</p><ul><li>添加SPDY支持。</li><li>添加HTTP2 HPACK编码支持。</li><li>添加动态TLS记录支持。</li></ul><p>nginx_auto_using_PRIORITIZE_CHACHA 补丁</p><ul><li>支持时使用 SSL_OP_PRIORITIZE_CHACHA</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/kn007/patch.git nginx-patch</span><br><span class="line"><span class="built_in">cd</span> /usr/src/nginx</span><br><span class="line">patch -p1 &lt; ../nginx-patch/nginx.patch </span><br><span class="line">patch -p1 &lt; ../nginx-patch/nginx_auto_using_PRIORITIZE_CHACHA.patch</span><br></pre></td></tr></table></figure><h3 id="使用-jemalloc-作为内存管理"><a href="#使用-jemalloc-作为内存管理" class="headerlink" title="使用 jemalloc 作为内存管理"></a>使用 jemalloc 作为内存管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/</span><br><span class="line">wget https://github.com/jemalloc/jemalloc/releases/download/5.1.0/jemalloc-5.1.0.tar.bz2</span><br><span class="line">tar xjvf jemalloc-5.1.0.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> jemalloc-5.1.0</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'/usr/local/lib'</span> &gt;&gt; /etc/ld.so.conf.d/local.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><h3 id="其他编译配置"><a href="#其他编译配置" class="headerlink" title="其他编译配置"></a>其他编译配置</h3><p>Nginx 默认会以 debug 模式编译，我们需要注释掉 <code>/usr/src/nginx/auto/cc/gcc</code> 中 <code>CFLAGS=&quot;$CFLAGS -g&quot;</code> 这行，这样可以减少生成文件的大小</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">'s@CFLAGS="$CFLAGS -g"@#CFLAGS="$CFLAGS -g"@'</span> /usr/src/nginx/auto/cc/gcc</span><br></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/nginx</span><br><span class="line">./configure \</span><br><span class="line">--user=www-data --group=www-data \</span><br><span class="line">--prefix=/usr/<span class="built_in">local</span>/nginx \</span><br><span class="line">--sbin-path=/usr/sbin/nginx \</span><br><span class="line">--with-compat --with-file-aio --with-threads \</span><br><span class="line">--with-http_v2_module --with-http_v2_hpack_enc \</span><br><span class="line">--with-http_spdy_module --with-http_realip_module \</span><br><span class="line">--with-http_flv_module --with-http_mp4_module \</span><br><span class="line">--with-openssl=../openssl --with-http_ssl_module \</span><br><span class="line">--with-pcre=../pcre-8.42 --with-pcre-jit \</span><br><span class="line">--with-zlib=../zlib --with-http_gzip_static_module \</span><br><span class="line">--add-module=../ngx_brotli \</span><br><span class="line">--with-ld-opt=-ljemalloc</span><br><span class="line"></span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>Nginx 的可执行文件安装在 <code>/usr/sbin/nginx</code> ，Nginx 配置在 <code>/usr/local/nginx/conf/</code> 里</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Nginx 已经安装上了，现在我们来配置网站，让它跑起来</p><h3 id="Nginx-全局配置"><a href="#Nginx-全局配置" class="headerlink" title="Nginx 全局配置"></a>Nginx 全局配置</h3><p>把以下内容覆盖填入 <code>/usr/local/nginx/conf/nginx.conf</code></p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> www-data;</span><br><span class="line"><span class="attribute">pid</span> /var/run/nginx.pid;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">aio</span> threads;</span><br><span class="line">    <span class="attribute">directio</span> <span class="number">512k</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">log_not_found</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">types_hash_max_size</span> <span class="number">2048</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">16M</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># MIME</span></span><br><span class="line">    <span class="attribute">include</span> mime.types;</span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Logging</span></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/access.log;</span><br><span class="line">    <span class="attribute">error_log</span> /var/log/nginx/error.log <span class="literal">warn</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Gzip</span></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_proxied</span> any;</span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain text/css text/xml application/json application/javascript application/xml+rss application/atom+xml image/svg+xml;</span><br><span class="line">    <span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\.(?!.*SV1)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Brotli</span></span><br><span class="line">    <span class="attribute">brotli</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">brotli_comp_level</span> <span class="number">6</span>;</span><br><span class="line">    <span class="attribute">brotli_static</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">brotli_types</span> text/plain text/css text/xml application/json application/javascript application/xml+rss application/atom+xml image/svg+xml;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> vhost/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx-站点配置"><a href="#Nginx-站点配置" class="headerlink" title="Nginx 站点配置"></a>Nginx 站点配置</h3><p>我们已经在全局配置里设置了包含 <code>/usr/local/nginx/conf/vhost/</code> 目录下的 conf 文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/<span class="built_in">local</span>/nginx/conf/vhost/</span><br></pre></td></tr></table></figure><p>然后在 <code>/usr/local/nginx/conf/vhost/</code> 里创建站点配置，比如我的是 <code>onmp.ooo.conf</code></p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span> onmp.ooo;</span><br><span class="line">  <span class="attribute">root</span> /wwwroot/onmp.ooo;</span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">index</span>  index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 HTTP 的站点配置就弄好了，不过还站点还没页面，我们把 Nginx 的欢迎也面给放进去</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /wwwroot</span><br><span class="line">cp -r /usr/<span class="built_in">local</span>/nginx/html /wwwroot/onmp.ooo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置站点目录权限</span></span><br><span class="line">chown -R www-data:www-data /wwwroot/</span><br><span class="line">find /wwwroot/ -<span class="built_in">type</span> d -<span class="built_in">exec</span> chmod 755 &#123;&#125; \;</span><br><span class="line">find /wwwroot/ -<span class="built_in">type</span> f -<span class="built_in">exec</span> chmod 644 &#123;&#125; \;</span><br></pre></td></tr></table></figure><h3 id="service-配置"><a href="#service-配置" class="headerlink" title="service 配置"></a>service 配置</h3><p>service 命令用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、查看状态（status）等，我们是编译安装的，所以要手动创建服务文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/lib/systemd/system/</span><br></pre></td></tr></table></figure><p>编辑 <code>/usr/lib/systemd/system/nginx.service</code> 写入以下内容</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"><span class="attribute">Description</span>=nginx - high performance web server</span><br><span class="line"><span class="attribute">After</span>=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="attribute">Type</span>=forking</span><br><span class="line"><span class="attribute">PIDFile</span>=/var/run/nginx.pid</span><br><span class="line"><span class="attribute">ExecStartPost</span>=/bin/sleep 0.1</span><br><span class="line"><span class="attribute">ExecStartPre</span>=/usr/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="attribute">ExecStart</span>=/usr/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="attribute">ExecReload</span>=/usr/sbin/nginx -s reload</span><br><span class="line"><span class="attribute">ExecStop</span>=/usr/sbin/nginx -s stop</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"><span class="attribute">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload <span class="comment">#重载</span></span><br><span class="line">systemctl <span class="built_in">enable</span> nginx <span class="comment">#开机启动</span></span><br><span class="line">systemctl start nginx <span class="comment">#运行</span></span><br></pre></td></tr></table></figure><p>我们现在可以用 <code>service</code> 或 <code>systemctl</code> 管理 nginx 了</p><p>启动 Nginx 后 HTTP 页面就正常了，打开 onmp.ooo 就能看到 Welcome to nginx!</p><h3 id="签发证书"><a href="#签发证书" class="headerlink" title="签发证书"></a>签发证书</h3><p>配置 HTTPS 首先要有证书，我这里是使用 <a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="noopener">acme.sh</a> 自动颁发 Let’s Encrypt 的证书</p><p>具体使用教程看我的另一篇教程 <a href="https://zhih.me/acme-sh-guide/">使用acme.sh获取免费SSL证书</a></p><p>当然，你要是已经有了 SSL 证书，直接看下面配置文件里证书存放的目录，直接放到里面去就行，其他操作一样的</p><h3 id="HTTPS-站点配置"><a href="#HTTPS-站点配置" class="headerlink" title="HTTPS 站点配置"></a>HTTPS 站点配置</h3><p>因为我给 OpenSSL 打的是 equal-1.1.1_ciphers 补丁，所以 ssl_ciphers 配置文件如下，如果你打的是别的补丁，则需要查看 <a href="https://github.com/hakasenyang/openssl-patch" target="_blank" rel="noopener">https://github.com/hakasenyang/openssl-patch</a> 给的配置</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> onmp.ooo;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://onmp.ooo<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line">    <span class="attribute">server_name</span> onmp.ooo;</span><br><span class="line">    <span class="attribute">root</span> /wwwroot/onmp.ooo;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># SSL</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>         /usr/local/nginx/conf/ssl/onmp.ooo.cer;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>     /usr/local/nginx/conf/ssl/onmp.ooo.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> <span class="string">'[TLS13+AESGCM+AES128|TLS13+AESGCM+AES256|TLS13+CHACHA20]:[EECDH+ECDSA+AESGCM+AES128|EECDH+ECDSA+CHACHA20]:EECDH+ECDSA+AESGCM+AES256:EECDH+ECDSA+AES128+SHA:EECDH+ECDSA+AES256+SHA:[EECDH+aRSA+AESGCM+AES128|EECDH+aRSA+CHACHA20]:EECDH+aRSA+AESGCM+AES256:EECDH+aRSA+AES128+SHA:EECDH+aRSA+AES256+SHA:RSA+AES128+SHA:RSA+AES256+SHA:RSA+3DES'</span>;</span><br><span class="line">    <span class="attribute">ssl_ecdh_curve</span> X25519:P-<span class="number">256</span>:P-<span class="number">384</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">50m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">1d</span>;</span><br><span class="line">    <span class="attribute">ssl_session_tickets</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># OCSP Stapling</span></span><br><span class="line">    <span class="attribute">ssl_stapling</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_stapling_verify</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">resolver</span> <span class="number">119.29.29.29</span> <span class="number">8.8.8.8</span> valid=<span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">resolver_timeout</span> <span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Security headers</span></span><br><span class="line">    <span class="attribute">add_header</span> X-Frame-Options <span class="string">"SAMEORIGIN"</span> always;</span><br><span class="line">    <span class="attribute">add_header</span> X-XSS-Protection <span class="string">"1; mode=block"</span> always;</span><br><span class="line">    <span class="attribute">add_header</span> X-Content-Type-Options <span class="string">"nosniff"</span> always;</span><br><span class="line">    <span class="attribute">add_header</span> Referrer-Policy <span class="string">"no-referrer-when-downgrade"</span> always;</span><br><span class="line">    <span class="attribute">add_header</span> Strict-Transport-Security <span class="string">"max-age=31536000; includeSubDomains; preload"</span> always;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="attribute">index</span>  index.html;</span><br><span class="line">      <span class="attribute">http2_push</span> /style.css;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf|ico)$</span> &#123;</span><br><span class="line">      <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(js|css)?$</span> &#123;</span><br><span class="line">      <span class="attribute">expires</span> <span class="number">15d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是完整的站点配置文件，覆盖 <code>/usr/local/nginx/conf/vhost/onmp.ooo.conf</code> 后，使用 <code>service nginx reload</code> 重载 Nginx 再打开站点就能看到 HTTPS 的页面了</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在 Chrome 65 或更新的版本中，打开开发者工具的 Security 菜单，就能在里面看到 站点是否以 TLS1.3 连接</p><p><img src="https://pic.zhih.me/blog/posts/make-your-website-support-tls1.3/chrome.jpg" alt="chrome"></p><p>或者可以到 SSL Server Test：<a href="https://www.ssllabs.com/ssltest/index.html" target="_blank" rel="noopener">https://www.ssllabs.com/ssltest/index.html</a> 进行测试</p><p><img src="https://pic.zhih.me/blog/posts/make-your-website-support-tls1.3/ssllabs.jpg" alt="ssllabs"></p><p>我只开启了 TLSv1.2 TLSv1.3 的支持，如果需要，你可以自己增加其他协议的支持</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>人们的生活已经离不开网络，所以网络安全在现在和未来都至关重要，曾经很多站长都以 HTTPS 影响站点速度为由，又或者说 SSL 证书昂贵，拒绝配 HTTPS，而随着技术的迭代升级，配置 HTTPS+HTTPS2 能提高网站速度，而 SSL 不仅可以免费获取，还可以使用命令自动获取自动更新，在我看来已经没有理由不配置 HTTPS 了，所以希望各位站长，都赶紧上车吧</p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> https </tag>
            
            <tag> web优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Syncthing就是我要的同步备份软件</title>
      <link href="/syncthing-the-best/"/>
      <url>/syncthing-the-best/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>数据无价，平时不注意备份，电脑突然翻车就追悔莫及啦。</p><p>最开始的时候，我在路由器上开启 Samba，每次编辑完项目就手动拷贝到路由器硬盘里，麻烦程度可想而知，后来又用了 Google Drive/One Drive，又因为它们的网络不理想，就又放弃使用了。</p><p>其实就是很简单的需求，自动备份、速度快，然后去找了一下，发现一堆人推荐用 Rsync，这货我只在 VPS 上用过，拿来做镜像同步，但是要做实时同步，不好配置。</p><p>我就想，这需求应该有一大堆人有吧，就去 github 搜索 sync，发现 Syncthing 这么个好东西，截止 2018-06-13 已经得到 20k+ 的 star，并且更新很活跃</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://pic.zhih.me/blog/posts/syncthing-the-best/logo.jpg" alt="logo"></p><p>Syncthing 是一个文件连续同步软件</p><p>项目地址：<a href="https://github.com/syncthing/syncthing" target="_blank" rel="noopener">https://github.com/syncthing/syncthing</a></p><p>它有以下特性：</p><ul><li><p>跨平台</p><ul><li>使用 Golang 开发，几乎能在所有平台上使用，包括常见的安卓手机和路由器平台</li></ul></li><li><p>易于使用</p><ul><li>只需要下载运行，打开浏览设置本地目录和远程主机，其他的不需要管</li></ul></li><li><p>安全</p><ul><li>管理页可以设置密码，可以设置 https，设置备份需要两边都确认，使用唯一设备标识进行确认</li></ul></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Syncthing 有多种安装方式</p><p>有一定 Linux 基础的人，可以使用下面的配置来设置启动服务</p><ul><li><a href="https://github.com/syncthing/syncthing/tree/master/etc" target="_blank" rel="noopener">https://github.com/syncthing/syncthing/tree/master/etc</a></li></ul><p>Windows，Mac，Linux 和安卓手机可以在这里下载有 GUI 界面的程序使用</p><ul><li><a href="https://docs.syncthing.net/users/contrib.html#gui-wrappers" target="_blank" rel="noopener">https://docs.syncthing.net/users/contrib.html#gui-wrappers</a></li></ul><p>其他方法可以自己决定，我是直接下载安装包命令行启动的</p><h3 id="在-MacOS-上安装"><a href="#在-MacOS-上安装" class="headerlink" title="在 MacOS 上安装"></a>在 MacOS 上安装</h3><p>我用的是 MacOS，可以直接使用 homebrew 安装启动，并且可以开机自动启动，你也可以到这里 <a href="https://github.com/sieren/QSyncthingTray/releases" target="_blank" rel="noopener">QSyncthingTray</a> 下载 MacOS 的 GUI 版</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install syncthing</span><br></pre></td></tr></table></figure><p>启动服务（同时设置开机启动）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew services start syncthing</span><br></pre></td></tr></table></figure><p>停止服务（同时关闭自启）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew services stop syncthing</span><br></pre></td></tr></table></figure><p>手动启动（不会开机自启）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">syncthing</span><br></pre></td></tr></table></figure><p>启动进程后，可以用浏览器打开 <code>http://localhost:8384/</code> 来查看 web 管理页</p><h3 id="在-Windows-上安装"><a href="#在-Windows-上安装" class="headerlink" title="在 Windows 上安装"></a>在 Windows 上安装</h3><p>Windows 直接在这里 <a href="https://github.com/canton7/SyncTrayzor/releases" target="_blank" rel="noopener">SyncTrayzor</a> 下载软件运行</p><h3 id="在-Linux-VPS-上安装"><a href="#在-Linux-VPS-上安装" class="headerlink" title="在 Linux VPS 上安装"></a>在 Linux VPS 上安装</h3><p>大多数发行版和不同 CPU 平台的安装包，可以在这里 <a href="https://github.com/syncthing/syncthing/releases" target="_blank" rel="noopener">Syncthing</a> 找到，把它下载到你想要放在的目录然后设置权限，使用命令运行</p><p>文章开头有 GUI 版本的链接，不过我要装在没有 GUI 的 VPS 上，所以直接用命令行运行，系统用的是 Debian 9，然后用 supervisor 进程守护来启动的</p><p>碰巧前几天之前的一个客户，他的 VPS 做迁移，阿里云送了张代金券，然后客户就送给我了</p><p><img src="https://pic.zhih.me/blog/posts/syncthing-the-best/aff.jpg" alt="aff"></p><p>然后续费 9 个月的阿里云学生机，美滋滋😎</p><p>虽然带宽比较低，但是对于这种连续同步的备份来说，在第一次备份之后，后面都是增量备份了，除非你都是备份大文件，要不对带宽的要求不是很高，另外 40G 的盘，完全够我备份用了，阿里云最主要就是稳定，很适合做我的备份机</p><h4 id="下载-Syncthing"><a href="#下载-Syncthing" class="headerlink" title="下载 Syncthing"></a>下载 Syncthing</h4><p>下载最新的包，解压，移动到 <code>/bin/</code> 里，改权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/syncthing/syncthing/releases/download/v0.14.49-rc.1/syncthing-linux-amd64-v0.14.49-rc.1.tar.gz</span><br><span class="line"></span><br><span class="line">tar xzvf ./syncthing-linux-amd64-v0.14.49-rc.1.tar.gz</span><br><span class="line"></span><br><span class="line">mv ./syncthing-linux-amd64-v0.14.49-rc.1/syncthing /bin/</span><br><span class="line"></span><br><span class="line">chmod +x /bin/syncthing</span><br></pre></td></tr></table></figure><h4 id="进程守护"><a href="#进程守护" class="headerlink" title="进程守护"></a>进程守护</h4><p>安装 supervisor</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install supervisor</span><br></pre></td></tr></table></figure><p>配置守护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/supervisor/conf.d/syncthing.conf</span><br></pre></td></tr></table></figure><p>填入以下内容</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[program:syncthing]</span><br><span class="line">command = /bin/syncthing -no-browser <span class="attribute">-home</span>=<span class="string">"/root/.config/syncthing"</span></span><br><span class="line">directory = /root</span><br><span class="line">autorestart = <span class="literal">True</span></span><br><span class="line">user = root</span><br><span class="line">environment = <span class="attribute">STNORESTART</span>=<span class="string">"1"</span>, <span class="attribute">HOME</span>=<span class="string">"/root"</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>，我例子里使用的是 root 用户，所以响应的目录是 <code>/root</code>，你要是使用其他用户，应该是 <code>/home/用户名</code>，就是你登录时默认所在的目录</p><p>现在就可以使用 <code>supervisorctl</code> 命令来管理进程了</p><ul><li>启动</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">supervisorctl start syncthing</span><br></pre></td></tr></table></figure><ul><li>重启</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">supervisorctl restart syncthing</span><br></pre></td></tr></table></figure><ul><li>停止</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">supervisorctl stop syncthing</span><br></pre></td></tr></table></figure><p>启动进程后，可以用浏览器打开 <code>http://你的IP:8384/</code> 来查看 web 管理页</p><p>如果无法打开页面，需要修改 <code>/.config/syncthing/config.xml</code> 里的 <code>127.0.0.1:8384</code> 字段为 <code>0.0.0.0:8384</code>，或者你可以和我一样使用 nginx 做反向代理，前提是你知道怎么做</p><h3 id="在路由器上安装"><a href="#在路由器上安装" class="headerlink" title="在路由器上安装"></a>在路由器上安装</h3><p>目前 <a href="https://entware.net/" target="_blank" rel="noopener">Entware</a> 源里已经有这个包了，但是我发现它是个旧版本，并且有问题，所以这里我选择手动安装</p><p>这里的例子是 LEDE x64 但是也适合一切安装了 Entware 的路由器</p><p>在这里 <a href="https://github.com/syncthing/syncthing/releases" target="_blank" rel="noopener">Syncthing</a> 下载对应 CPU 平台的安装包，可以用 <code>uname -m</code> 查看，我这里是 x86_64 所以选择 amd64</p><h4 id="下载-syncthing"><a href="#下载-syncthing" class="headerlink" title="下载 syncthing"></a>下载 syncthing</h4><p>下载最新的包，解压，移动到 <code>/opt/bin/</code> 里，改权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/syncthing/syncthing/releases/download/v0.14.49-rc.1/syncthing-linux-amd64-v0.14.49-rc.1.tar.gz</span><br><span class="line"></span><br><span class="line">tar xzvf ./syncthing-linux-amd64-v0.14.49-rc.1.tar.gz</span><br><span class="line"></span><br><span class="line">mv ./syncthing-linux-amd64-v0.14.49-rc.1/syncthing /opt/bin/</span><br><span class="line"></span><br><span class="line">chmod +x /opt/bin/syncthing</span><br></pre></td></tr></table></figure><h4 id="添加启动命令"><a href="#添加启动命令" class="headerlink" title="添加启动命令"></a>添加启动命令</h4><p>创建并编辑 <code>/opt/etc/init.d/S92syncthing</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /opt/etc/init.d/S92syncthing</span><br></pre></td></tr></table></figure><p>在里面填上下面所有字段</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">ENABLED=yes</span><br><span class="line">PROCS=syncthing</span><br><span class="line">ARGS=<span class="string">"-home=/opt/etc/syncthing"</span></span><br><span class="line">PREARGS=<span class="string">""</span></span><br><span class="line">DESC=<span class="variable">$PROCS</span></span><br><span class="line">PATH=/opt/sbin:/opt/bin:/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -d /opt/etc/syncthing ]; <span class="keyword">then</span></span><br><span class="line">   /opt/bin/syncthing -generate=<span class="string">"/opt/etc/syncthing"</span></span><br><span class="line">   sed -i <span class="string">'s|127.0.0.1:8384|0.0.0.0:8384|'</span> /opt/etc/syncthing/config.xml</span><br><span class="line"><span class="keyword">elif</span> [[ -f /opt/etc/syncthing/config.xml -a <span class="string">"127.0.0.1:8384"</span>==<span class="string">"127.0.0.1:8384"</span> ]]; <span class="keyword">then</span></span><br><span class="line">   sed -i <span class="string">'s|127.0.0.1:8384|0.0.0.0:8384|'</span> /opt/etc/syncthing/config.xml</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">. /opt/etc/init.d/rc.func</span><br></pre></td></tr></table></figure><p>然后给权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x /opt/etc/init.d/S92syncthing</span><br></pre></td></tr></table></figure><p>用法: /opt/etc/init.d/S92syncthing (start|stop|restart|check)</p><p>启动服务就能在浏览器打开 <code>路由器IP:8384</code> 例如 <code>192.168.1.1:8384</code> 打开管理页了</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>易于使用是 Syncthing 的一个重要特性，打开管理页，一目了然</p><p>首次打开管理页，所有平台上都是一样的</p><p><img src="https://pic.zhih.me/blog/posts/syncthing-the-best/syncthing.jpg" alt="syncthing"></p><p>然后你需要做的就是</p><h3 id="设置用户名、密码"><a href="#设置用户名、密码" class="headerlink" title="设置用户名、密码"></a>设置用户名、密码</h3><p><img src="https://pic.zhih.me/blog/posts/syncthing-the-best/setpass.jpg" alt="setpass"></p><h3 id="设置文件夹"><a href="#设置文件夹" class="headerlink" title="设置文件夹"></a>设置文件夹</h3><p>删除默认的同步文件夹，添加新同步文件夹</p><p><img src="https://pic.zhih.me/blog/posts/syncthing-the-best/addlocal.jpg" alt="addlocal"></p><h3 id="添加远程设备"><a href="#添加远程设备" class="headerlink" title="添加远程设备"></a>添加远程设备</h3><p><img src="https://pic.zhih.me/blog/posts/syncthing-the-best/addremote.jpg" alt="addremote"></p><p>然后稍微等一分钟，两边就能连接上了</p><p>最终效果</p><p><img src="https://pic.zhih.me/blog/posts/syncthing-the-best/end.jpg" alt="end"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Syncthing 作为一款跨平台同步软件，它简单易用、功能完善强大，具有很高的稳定性，很容易让人想出各种使用场景，而且它还是开源的，感谢那上百位贡献者</p><p>本文简单介绍了初级使用方法，还未提及其他的诸如版本控制等功能，其他功能应用，如果以后我觉得值得一说，再更新了</p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MacOS读写NTFS，及EXT分区格式化和挂载</title>
      <link href="/macos-mount-ntfs-ext/"/>
      <url>/macos-mount-ntfs-ext/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>有时候需要在 MacOS 读写 NTFS 分区，但是系统默认只能读取不能写入，修改 fstab 和使用 Paragon NTFS 软件都可以实现读写，而我这里使用的是 osxfuse，因为它不仅能支持 NTFS, 还支持 Ext 等其他文件系统</p><p><img src="https://pic.zhih.me/blog/posts/macos-mount-ntfs-ext/panes.jpg" alt="panes"></p><p>以下操作需要关闭 SIP，进入恢复模式，在终端里输入 <code>csrutil disable</code>，再重启就关闭 SIP 了，黑苹果可以在 clover 里设置</p><h2 id="安装-osxfuse"><a href="#安装-osxfuse" class="headerlink" title="安装 osxfuse"></a>安装 osxfuse</h2><p><code>FUSE for OS X</code> 是用在 MacOS 上的第三方文件系统扩展，地址：<a href="https://github.com/osxfuse/osxfuse/wiki" target="_blank" rel="noopener">https://github.com/osxfuse/osxfuse/wiki</a></p><p>使用 <a href="https://brew.sh/" target="_blank" rel="noopener">homebrew</a> 安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask install osxfuse</span><br></pre></td></tr></table></figure><p><img src="https://pic.zhih.me/blog/posts/macos-mount-ntfs-ext/osxfuse.jpg" alt="osxfuse.jpg"></p><p>事实上 FUSE 是提供了提供了接口，要实现 NTFS 和 Ext 文件系统的支持，还需要安装模块</p><h2 id="读写-NTFS-分区"><a href="#读写-NTFS-分区" class="headerlink" title="读写 NTFS 分区"></a>读写 NTFS 分区</h2><p>让 MacOS 读写 NTFS 需要安装 ntfs-3g</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install ntfs-3g</span><br></pre></td></tr></table></figure><h3 id="手动挂载"><a href="#手动挂载" class="headerlink" title="手动挂载"></a>手动挂载</h3><p>使用 <code>diskutil list</code> 查看分区，例如我的 U 盘是 <code>disk4s1</code></p><p>那么可以用以下命令挂载</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ~/Desktop/UDISK</span><br><span class="line">sudo ntfs-3g /dev/disk4s1 ~/Desktop/UDISK -o allow_other</span><br></pre></td></tr></table></figure><p>这样 U 盘就被挂载到桌面了</p><p>卸载这个分区的命令式是 <code>sudo umount /dev/disk4s1</code></p><p><strong>注意：</strong>不管是用什么方式挂载 NTFS 分区，都不建议挂载 win 的系统盘，有翻车嫌疑，所以当 ntfs-3g 发现你挂载的分区有 win 休眠和快速启动遗留的缓存时，会以只读模式挂载，如果实在需要修改 win 系统分区，需要在 win 里关闭快速启动</p><h3 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h3><p>我们知道，MacOS 开机时会自动挂载 NTFS 分区，但是只能读取</p><p>安装 ntfs-3g 后，我们需要让新的 mount_ntfs 替换系统自带的版本，实现写入</p><p>为了减少对系统的影响，我们把旧版本备份，并把新版本软链接过去</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv /sbin/mount_ntfs /sbin/mount_ntfs.bak</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/sbin/mount_ntfs /sbin/mount_ntfs</span><br></pre></td></tr></table></figure><p>重启生效，需要注意的是，每次升级或重装系统之后，需要重新做软链接</p><p>现在可以重新打开 SIP，在恢复模式的终端里，输入 <code>csrutil enable</code> 再重启，黑果可以在 clover 里设置</p><h2 id="EXT-格式化和挂载"><a href="#EXT-格式化和挂载" class="headerlink" title="EXT 格式化和挂载"></a>EXT 格式化和挂载</h2><p>ext2、ext3、ext4 格式化需要安装 e2fsprogs，挂载需要安装 <a href="https://github.com/alperakcan/fuse-ext2" target="_blank" rel="noopener">fuse-ext2</a></p><p>fuse-ext2 也依赖于 e2fsprogs，所以先装它</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install e2fsprogs</span><br></pre></td></tr></table></figure><p>再安装 fuse-ext2</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install https://raw.githubusercontent.com/yalp/homebrew-core/fuse-ext2/Formula/fuse-ext2.rb</span><br></pre></td></tr></table></figure><p>根据提示，设置面板里的选项需要这样操作才能显示</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp -pR /usr/<span class="built_in">local</span>/opt/fuse-ext2/System/Library/Filesystems/fuse-ext2.fs /Library/Filesystems/</span><br><span class="line"></span><br><span class="line">sudo chown -R root:wheel /Library/Filesystems/fuse-ext2.fs</span><br><span class="line"></span><br><span class="line">sudo cp -pR /usr/<span class="built_in">local</span>/opt/fuse-ext2/System/Library/PreferencePanes/fuse-ext2.prefPane /Library/PreferencePanes/</span><br><span class="line"></span><br><span class="line">sudo chown -R root:wheel /Library/PreferencePanes/fuse-ext2.prefPane</span><br></pre></td></tr></table></figure><p><img src="https://pic.zhih.me/blog/posts/macos-mount-ntfs-ext/ext.jpg" alt="ext"></p><p>这样就装好了</p><h3 id="EXT-分区格式化"><a href="#EXT-分区格式化" class="headerlink" title="EXT 分区格式化"></a>EXT 分区格式化</h3><p>前面我们已经安装了 e2fsprogs，现在可以使用它提供的命令来格式化分区</p><p>先设置变量让 e2fs 库里的命令暴露出来，将以下字段加在 shell 的配置文件中，我用的是 zsh，所以加在 <code>~/.zshrc</code> 里</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="string">"/usr/local/opt/e2fsprogs/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="string">"/usr/local/opt/e2fsprogs/sbin:<span class="variable">$PATH</span>"</span></span><br></pre></td></tr></table></figure><p>重启终端或执行 <code>source ~/.zshrc</code> 生效</p><p>现在就能执行 <code>mkfs.ext2</code> <code>mkfs.ext3</code> <code>mkfs.ext4</code> 等命令了</p><p>用法：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 [-c|-l 文件名] [-b 块大小] [-C 簇大小]</span><br><span class="line">    [-i 每inode的字节数] [-I inode大小] [-J 日志选项]</span><br><span class="line">    [-G 弹性组大小] [-N inode数] [-d 根目录]</span><br><span class="line">    [-m 保留块所占百分比] [-o 创始系统名]</span><br><span class="line">    [-g 每组的块数] [-L 卷标] [-M 上一次挂载点]</span><br><span class="line">    [-O 特性[,...]] [-r 文件系统版本] [-E 扩展选项[,...]]</span><br><span class="line">    [-t 文件系统类型] [-T 用法类型] [-U UUID] [-e 错误行为][-z 撤销文件]</span><br><span class="line">    [-jnqvDFKSV] 设备 [块数]</span><br></pre></td></tr></table></figure><p>使用 <code>diskutil list</code> 查看分区，例如我想要格式化为 ext4 的分区是 <code>disk3s1</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkfs.ext4 /dev/disk3s1</span><br></pre></td></tr></table></figure><h3 id="挂载-EXT-分区"><a href="#挂载-EXT-分区" class="headerlink" title="挂载 EXT 分区"></a>挂载 EXT 分区</h3><p>使用 <code>diskutil list</code> 查看分区，例如我有个 Ext4 分区是 <code>disk3s1</code></p><p>那么命令是这样的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ~/Desktop/DISK</span><br><span class="line">sudo mount -t fuse-ext2 /dev/disk3s1 ~/Desktop/DISK</span><br></pre></td></tr></table></figure><p>这样就挂载上了</p><p>卸载这个分区的命令式是 <code>sudo umount /dev/disk3s1</code></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>平常这些挂载工具用的确实不是很多，但是需要用的时候，又很无奈，所以直接写个笔记记录一下，以后要用的时候方便些</p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WEB是如何工作的</title>
      <link href="/how-the-web-works/"/>
      <url>/how-the-web-works/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本来很犹豫是否要写一下这篇文章的，毕竟自己知之甚少，说些浅的知识还行，一旦深入，就会漏了马脚。但是，另一方面想，既然知道自己懂的不够，就更应该把知道的给梳理出来，也好进行下一步的学习。所以这篇文章也算是对当前所学所知进行一个总结吧，遛😂。</p><h2 id="简解"><a href="#简解" class="headerlink" title="简解"></a>简解</h2><p>先上一个大概的图解</p><p><img src="https://pic.zhih.me/blog/posts/how-the-web-works/过程图解.jpg" alt="过程图解"></p><p>上图简单的解释了打开一个网页的过程，稍微详细的解释就是：</p><ol><li><p>浏览器得到网址，并把网址拆解为域名和路径<br><img src="https://pic.zhih.me/blog/posts/how-the-web-works/简解url.jpg" alt="URL"></p></li><li><p>浏览器寻找域名对应的 IP</p><ul><li>先在浏览器自己的缓存里找，如果之前访问过，会有缓存</li><li>如果没有缓存，则让手机或电脑向 DNS 服务器请求获取</li></ul></li><li><p>浏览器向服务器请求数据</p></li><li><p>服务器解析请求，得到请求的路径参数等</p><ul><li>如果是静态页面，直接找到对应的静态文件</li><li>如果是动态页面，调用动态语言处理数据合成页面，再交给 HTTP 服务器</li></ul></li><li><p>服务器把页面发回浏览器</p></li><li><p>浏览器得到数据，进行解析、渲染、输出</p></li></ol><p>最终就看到了网页。</p><hr><p>从上面的简解我们可以知道，访问的过程大概可分为：URL，DNS 查询，HTTP，浏览器，这四个部分。</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><blockquote><p>URL 是 Uniform Resource Locator 的简写，中文：统一资源定位符，在 web 中很多时候被叫做 ‘网址’。</p></blockquote><p>URL 的标准格式如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">协议:[<span class="string">//地址[:端口</span>]][<span class="string">/路径</span>]文件[<span class="string">?数据</span>][<span class="symbol">#锚点</span>]</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>协议： 在 web 中通常使用 http，https</span><br><span class="line"><span class="bullet">- </span>地址： 域名或者 IP 地址</span><br><span class="line"><span class="bullet">- </span>端口： 默认情况下，http 使用 80 端口、https 使用 443 端口的时候，可以省略</span><br><span class="line"><span class="bullet">- </span>路径： 要访问资源所在的目录</span><br><span class="line"><span class="bullet">- </span>文件： 当请求的是具体一个文件时，比如一张图片，需要写清楚，否则由服务器决定返回设置的文件，一般是 <span class="code">`index.html`</span></span><br><span class="line"><span class="bullet">- </span>数据： ? 后写 GET 请求的参数，每个参数以 &amp; 隔开，再以 = 分开参数名称与数据</span><br><span class="line"><span class="bullet">- </span>锚点： # 后面的数据不会被发送到服务器，它代表网页中的一个位置</span><br></pre></td></tr></table></figure><p><strong>发生了什么</strong></p><p>浏览器获取到用户输入的 URL，就按照以上格式进行解析，如果不符合标准格式，则会判断为用户输入了关键字，并跳转到搜索引擎搜索，当 URL 中存在不是 ASCII 的字符串时，会把字符串转成 <a href="https://en.wikipedia.org/wiki/Punycode" target="_blank" rel="noopener">punycode</a> 标准编码的字符串。</p><p>获取到域名后，浏览器首先会在浏览器的缓存中查找与它相关的资源，比如 DNS 缓存、静态资源缓存</p><p>浏览器的 DNS 缓存会把之前访问过的域名对应 IP 缓存起来，方便下次使用，一般会保存 TTL(DNS 服务器上缓存时间)、Expires(浏览器记录的到期时间)</p><p><strong>如果没有缓存</strong>，则进行下一步，DNS 查询</p><h2 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h2><blockquote><p>DNS 查询就是把网址翻译成 IP 地址。</p></blockquote><p>比方说你的电脑不知道 <a href="http://www.zhih.me" target="_blank" rel="noopener">www.zhih.me</a> 这个域名的 IP 地址，他就会向 DNS 服务器发送个请求，让 DNS 服务器帮他寻找，此时你的电脑就是一个 DNS 客户端，实际上整个具体过程会有不同的情况。</p><h3 id="域名的结构"><a href="#域名的结构" class="headerlink" title="域名的结构"></a>域名的结构</h3><p>想要理解 DNS 查询过程，还得先知道域名的结构。</p><p>以 <a href="http://www.zhih.me" target="_blank" rel="noopener">www.zhih.me</a> 这个域名为例，它是个全称域名（FQDN）</p><p>当你看到它时，应当从右往左读</p><p><img src="https://pic.zhih.me/blog/posts/how-the-web-works/domain1.jpg" alt="domain1"></p><p>而整个域名系统的结构是这样的</p><p><img src="https://pic.zhih.me/blog/posts/how-the-web-works/domain2.jpg" alt="domain2"></p><p>根域：储存了负责每个域（如com、cn、me等）的解析的域名服务器的地址信息</p><p>顶级域名(TLD)：分为通用、国家、赞助和地理几种类型，用于表示某些组织或用途</p><p>二级域名(SLD)：表示组织、个人、特定意义的名称</p><p>三级域名：例如：<code>sina.com.cn</code>，sina 是一个三级域名，同时又是 <code>com.cn</code> 的子域名</p><p>子域名：子域名与三级域名不同，例如：<code>www.zhih.me</code>，www 是 <code>zhih.me</code> 的子域名，但却不是三级域名</p><h3 id="DNS-查询过程"><a href="#DNS-查询过程" class="headerlink" title="DNS 查询过程"></a>DNS 查询过程</h3><p><strong>本地解析</strong></p><ol><li>查看 HOSTS 记录，如果有，直接返回结果</li><li>查看 DNS 缓存，看看它里面是不是有你设置的域名 IP 地址，缓存信息是通过以前的查询获得的，电脑关机时缓存将会被清空</li></ol><p><strong>直接解析</strong></p><p>本地找不到，就向你电脑里设置的 DNS 服务器请求，如果没有设置具体的地址，而是自动获取，就会从 ISP 中获取 DNS 服务器的 IP 地址，我自己使用的是腾讯的 DNS 服务器，我们一般把它叫做本地 DNS 服务器</p><p><img src="https://pic.zhih.me/blog/posts/how-the-web-works/dnsquery-1.jpg" alt="dnsquery-1"></p><p>当本地 DNS 服务器找不到结果时，就需要跟其他 DNS 服务器查询获取</p><p><strong>完整解析过程</strong></p><p><img src="https://pic.zhih.me/blog/posts/how-the-web-works/dnsquery-2.jpg" alt="dnsquery-2"></p><p>这个过程可以使用 dig 命令查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig www.zhih.me +trace</span><br></pre></td></tr></table></figure><p>这样，电脑就拿到域名对应的 IP 地址了</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>关于是什么，在维基百科已经写的很详细了，自己看看吧</p><p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a></p><p>前面我们已经找到了 IP，那么现在我们就要发送请求和接收响应了</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体</td></tr><tr><td>HEAD</td><td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>CONNECT</td><td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><blockquote><p>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。</p></blockquote><p>应该每个网民都不陌生，或多或少遇到过 404 not fount</p><p>状态码有相当多，在这里我就列出他们的分类</p><table><thead><tr><th>类型</th><th>类别</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>信息</td><td>请求已被接受，需要继续处理</td></tr><tr><td>2xx</td><td>成功</td><td>操作被成功接收并处理</td></tr><tr><td>3xx</td><td>重定向</td><td>需要客户端采取进一步的操作才能完成请求</td></tr><tr><td>4xx</td><td>客户端错误</td><td>请求的参数错误或无法完成请求</td></tr><tr><td>5xx</td><td>服务器错误</td><td>服务器在处理请求的过程中有错误或者异常</td></tr></tbody></table><h3 id="HTTP-消息结构"><a href="#HTTP-消息结构" class="headerlink" title="HTTP 消息结构"></a>HTTP 消息结构</h3><p>在 shell 中使用 <code>curl -v</code> 命令就可以看到请求和响应的消息了</p><p>以最常用的 get 请求为例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -v https://mov.zhih.me/weapp/list/1/2</span><br></pre></td></tr></table></figure><p><img src="https://pic.zhih.me/blog/posts/how-the-web-works/res_req.jpg" alt="res_req.jpg"></p><h3 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h3><p>请求报文的一般包括以下格式：请求行、请求头部、空行和请求数据</p><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">GET /weapp/list/<span class="number">1</span>/<span class="number">2</span> HTTP/<span class="number">2</span></span><br><span class="line"><span class="comment">//请求行: 请求方法 请求URI HTTP协议/协议版本</span></span><br><span class="line">Host: mov.zhih.me</span><br><span class="line"><span class="comment">//服务端的主机名</span></span><br><span class="line">user-agent:Mozilla/<span class="number">5.0</span> (Macintosh<span class="comment">; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36</span></span><br><span class="line"><span class="comment">//浏览器 UA</span></span><br><span class="line">accept:text/html,application/xhtml+xml,application/xml<span class="comment">;q=0.9,image/webp,image/apng,*/*;q=0.8</span></span><br><span class="line"><span class="comment">//客户端能接收的mine</span></span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line"><span class="comment">//是否支持流压缩</span></span><br><span class="line"><span class="meta"># 空行</span></span><br><span class="line"><span class="meta"># 请求数据</span></span><br></pre></td></tr></table></figure><p>请求头部就是请求行和空行之间的键值对</p><h3 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h3><p>响应报文也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</p><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">2</span> <span class="number">200</span></span><br><span class="line"><span class="comment">//状态行：HTTP协议版本号， 状态码， 状态消息</span></span><br><span class="line"><span class="keyword">server</span>: nginx/<span class="number">1.14</span><span class="number">.0</span></span><br><span class="line"><span class="comment">//web 服务器软件名及版本</span></span><br><span class="line"><span class="keyword">date</span>: Thu, <span class="number">17</span> May <span class="number">2018</span> <span class="number">14</span>:<span class="number">46</span>:<span class="number">50</span> GMT</span><br><span class="line"><span class="comment">//发送时间</span></span><br><span class="line">content-type: application/json; charset=utf<span class="number">-8</span></span><br><span class="line"><span class="comment">//服务器发送信息的类型</span></span><br><span class="line">content-length: <span class="number">589</span></span><br><span class="line"><span class="comment">//主体内容长度</span></span><br><span class="line"><span class="meta"># 空行 </span></span><br><span class="line">&#123;<span class="string">"code"</span>:<span class="number">200</span>,<span class="string">"data"</span>:[&#123;<span class="string">"rank"</span>:<span class="number">1</span>,<span class="string">"movid"</span>:<span class="number">1292052</span>,<span class="string">"rating"</span>:<span class="number">9.6</span>,<span class="string">"title"</span>:<span class="string">"肖申克的救赎"</span>,<span class="string">"genres"</span>:[<span class="string">"犯罪"</span>,<span class="string">"剧情"</span>],<span class="string">"year"</span>:<span class="number">1994</span>,<span class="string">"directors"</span>:[<span class="string">"弗兰克·德拉邦特"</span>],<span class="string">"casts"</span>:[<span class="string">"蒂姆·罗宾斯"</span>,<span class="string">"摩根·弗里曼"</span>,<span class="string">"鲍勃·冈顿"</span>],<span class="string">"image"</span>:<span class="string">"https://img3.doubanio.com/view/photo/s_ratio_poster/public/p480747492.jpg"</span>&#125;,&#123;<span class="string">"rank"</span>:<span class="number">2</span>,<span class="string">"movid"</span>:<span class="number">1291546</span>,<span class="string">"rating"</span>:<span class="number">9.5</span>,<span class="string">"title"</span>:<span class="string">"霸王别姬"</span>,<span class="string">"genres"</span>:[<span class="string">"剧情"</span>,<span class="string">"爱情"</span>,<span class="string">"同性"</span>],<span class="string">"year"</span>:<span class="number">1993</span>,<span class="string">"directors"</span>:[<span class="string">"陈凯歌"</span>],<span class="string">"casts"</span>:[<span class="string">"张国荣"</span>,<span class="string">"张丰毅"</span>,<span class="string">"巩俐"</span>],<span class="string">"image"</span>:<span class="string">"https://img3.doubanio.com/view/photo/s_ratio_poster/public/p1910813120.jpg"</span>&#125;]&#125;% </span><br><span class="line"><span class="comment">//响应正文</span></span><br></pre></td></tr></table></figure><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>前面说了数据怎么发送到服务器，现在说说服务器如何处理收到的数据</p><p>当然，这部分的情况相当复杂，不同场景有不同的方案，我这里只简单的举二三的例子</p><h3 id="静态站点"><a href="#静态站点" class="headerlink" title="静态站点"></a>静态站点</h3><p>我的博客 zhih.me 就是个静态站点，通过模板引擎把数据渲染成静态 HTML 文件，这些文件就存在服务器上等待下载，浏览器获取页面就是个文件下载的过程。</p><ol><li>浏览器发送 HTTP 请求，请求里包含了文件的路径、主机名等信息</li><li>我的服务器监听了 80 和 443 端口，发现有数据传来，将请求抛给虚拟主机</li><li>虚拟主机发现请求的路径是 ‘/‘，就把网站根目录下的 <code>index.html</code> 返回给请求者</li></ol><h3 id="动态站点"><a href="#动态站点" class="headerlink" title="动态站点"></a>动态站点</h3><p>这里说的动态站点，指页面是由后端处理数据合成的</p><p>常见的例子就是 WordPress，WP 应该是现在被使用得最多的 CMS 了，它的处理过程应该是这样的</p><ol><li>浏览器发送 HTTP 请求，请求里包含了文件的路径、主机名等信息</li><li>我的服务器监听了 80 和 443 端口，发现有数据传来，发现有数据传来，将请求抛给虚拟主机</li><li>虚拟主机发现请求的路径是 ‘/‘，而 ‘/‘ 这个路径已经指定了 PHP 处理，于是把请求抛给了 <code>index.php</code> 处理</li><li>WP 解析请求里的数据，看看有什么参数，你访问的是首页，也没带什么参数，于是 WP 就从数据库里把首页的文章调出来，然后在 PHP 里遍历合成 HTML 文件，并交给虚拟主机</li><li>虚拟主机把 HTML 页面返回给请求者</li></ol><h3 id="前后分离站点"><a href="#前后分离站点" class="headerlink" title="前后分离站点"></a>前后分离站点</h3><p>前后分离是现在和未来的趋势，大多数 WebApp 都是这种架构，简单说就是使用 AJAX 获取数据在客户端进行渲染。</p><ol><li>获取静态资源（静态站点的整个过程），JS 跑起来后开始请求数据</li><li>后端程序获取请求，解析请求数据，从数据库里提取数据，返回数据</li><li>前端程序得到数据，遍历数据，渲染页面</li></ol><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>前面我们就是从浏览器开始的，现在又回到了浏览器，浏览器是个常用且看似简单的软件，但是讲真，原理真的挺复杂的，我这里只能说说解析和渲染相关的一点点皮毛知识，如有错误欢迎斧正。</p><p>打开浏览器开发者工具，访问一个网页，我们将看到以下信息</p><p><img src="https://pic.zhih.me/blog/posts/how-the-web-works/chrome.jpg" alt="chrome"></p><p>基本过程是这样的：</p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">加载 HTML -&gt; 解析 HTML -&gt; 构建 DOM 树 -&gt; 构建 CSSOM 树 -&gt; 构建渲染树 -&gt; 布局、绘制</span><br></pre></td></tr></table></figure><p><strong>但是</strong>，现代浏览器为了更快的显示页面，很多任务都是同时进行的，会一边解析 HTML，一边下载外部资源，还一边进行渲染。</p><h3 id="解析-HTML-并构建-DOM-树"><a href="#解析-HTML-并构建-DOM-树" class="headerlink" title="解析 HTML 并构建 DOM 树"></a>解析 HTML 并构建 DOM 树</h3><p>浏览器自上而下的解析 HTML 文档，并在解析的同时构建 DOM（文档对象模型） 树，DOM 树里有各个标签的属性和它们之间的关系</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">true<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">true<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">true<span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">true<span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">true<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释器深度遍历 HTML 文档，把 <code>&lt;html&gt;</code> <code>&lt;head&gt;</code> <code>&lt;body&gt;</code> 这些标签按照 W3C 标准，转换成 “定义它属性和规则的对象’”，然后将这些 “对象” 链接在树形结构里，这就是 DOM 树</p><p><img src="https://pic.zhih.me/blog/posts/how-the-web-works/dom-tree.png" alt="dom-tree"></p><p>在以上 HTML 结构例子中，<code>&lt;p&gt;</code> 和 <code>&lt;div&gt;</code> 是兄弟节点，在 DOM 树的构建过程中，当前节点所有的子节点全都构建完成后才会构建下一兄弟节点</p><h3 id="构建-CSSOM-树"><a href="#构建-CSSOM-树" class="headerlink" title="构建 CSSOM 树"></a>构建 CSSOM 树</h3><p>在上面的 HTML 中，<code>&lt;head&gt;</code> 里有个外部样式表 <code>style.css</code>，HTML 解析到这里时会向服务器请求资源，得到这样的资源：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">true<span class="attribute">font-size</span>: <span class="number">16px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; </span><br><span class="line">true<span class="attribute">font-weight</span>: bold </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123; </span><br><span class="line">true<span class="attribute">color</span>: red </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; </span><br><span class="line">true<span class="attribute">display</span>: none </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123; </span><br><span class="line">true<span class="attribute">float</span>: right </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和处理 HTML 类似，浏览器处理 CSS 构建了 CSSOM</p><p><img src="https://pic.zhih.me/blog/posts/how-the-web-works/cssom-tree.png" alt="cssom-tree"></p><h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>前面已经构建了 DOM 树和 CSSOM 树，现在浏览器就把它们合并成一个渲染树</p><p><img src="https://pic.zhih.me/blog/posts/how-the-web-works/render-tree-construction.png" alt="render-tree-construction"></p><p>在渲染树的构建过程中，浏览器遍历 DOM 树，然后对应 CSSOM 树给每个节点设置计算样式（最终样式），设置了 <code>display: none</code> 的节点，将会在渲染树中移除</p><p>这样，渲染树就包含了页面上所有可见的内容和它们的计算样式</p><h3 id="布局、绘制"><a href="#布局、绘制" class="headerlink" title="布局、绘制"></a>布局、绘制</h3><p>渲染树只包含了内容和样式，要放到浏览器窗口中，还需要计算它们在窗口里的确切的位置和大小，这个过程叫做布局，也称为“自动重排”</p><p>浏览器从渲染树的根节点开始遍历，我们可以想象为有外向里的过程，先确定外层的位置大小，在向里层计算</p><blockquote><p>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素</p></blockquote><p>布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为“绘制”或“栅格化”</p><h3 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h3><p>当 DOM 或 CSSOM 被修改时，会发生重排（Reflow），也就是把上面的步骤重新来一遍，这样才能确定哪些像素需要在屏幕上进行重新渲染，这个过程也被叫做回流</p><p>如果改变的属性与元素的位置大小无关，比如背景颜色，那么浏览器只会重新绘制那个元素，这个过程叫重绘（Repaint）</p><blockquote><p>重排必然会引起重绘，重绘则不一定会重排</p></blockquote><h3 id="CSS、JS-阻塞"><a href="#CSS、JS-阻塞" class="headerlink" title="CSS、JS 阻塞"></a>CSS、JS 阻塞</h3><p>默认情况下，CSS 是阻塞渲染的资源，浏览器需要等 DOM 和 CSSDOM 都准备好之后才会渲染，注意，这里说的是阻塞渲染，而不是阻塞 DOM 的构建，事实上 DOM 和 CSSDOM 的构建是可以同时进行的</p><p>构建 CSSOM 会阻塞它后面 JavaScript 语句的执行，而 JavaScript 语句的执行又会阻止 CSSOM 的构建，原因很简单，因为 JavaScript 执行时可能会改变 CSSOM，同时进行会对性能产生影响</p><p>除非将 JavaScript 显式声明为异步，否则它会阻止构建 DOM，因为默认情况下，浏览器遇到 <code>&lt;script&gt;</code> 标签时会直接执行</p><p>所以，我们需要尽量把 CSS 放在网页头部，避免太晚才构建 CSSOM，影响渲染；尽量把 JavaScript 放在网页底部，并且设置 async、defer 属性，避免阻塞 DOM 的构建。defer 是“渲染完再执行”，async 是“下载完就执行”，defer 如果有多个脚本，会按照在页面中出现的顺序加载，多个async 脚本不能保证加载顺序。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/</a></p><p><a href="https://astaxie.gitbooks.io/build-web-application-with-golang/content/zh/03.1.html" target="_blank" rel="noopener">https://astaxie.gitbooks.io/build-web-application-with-golang/content/zh/03.1.html</a></p><p><a href="https://github.com/alex/what-happens-when" target="_blank" rel="noopener">https://github.com/alex/what-happens-when</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实就是个浏览器工作过程的拆析，然后涉及到相当多的知识点，并且这些都是搞 WEB 的必知的，写完这么多也算是消化了，下一步可能写写 WEB 性能优化相关的吧，也是一个很值得写的点</p><p>知识就是力量 – 培根</p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>做了个电影排行列表小程序</title>
      <link href="/my-weapp-topmov/"/>
      <url>/my-weapp-topmov/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>小程序叫：TOP 电影看不完</p><p><img src="https://pic.zhih.me/blog/posts/my-weapp-topmov/screenshot.jpg" alt="截图"></p><p>最近把这个小程序给基本完成了，这个‘完成’，是指最初我设想的功能都实现了。其实半年前就开始着手了，不过断断续续的，后来还回家学车、过年等等，一直没有把它完成。最近又把它捡起来，主要是把后端给完成了。</p><p>我爱拿两个东西来做练手的项目🤪🤪，一是天气，二是电影列表。主要原因还是因为有免费的 API，然后是功能明确。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul><li>搜索<ul><li>先初步建立 top250 的列表，然后搜索</li><li>搜索内容包括片名、类型、时间、主演、评分、排名</li></ul></li><li>已看<ul><li>标记看过的电影，看过就看过了，没有撤销选项😎</li></ul></li><li>收藏<ul><li>点击收藏，加入收藏列表</li></ul></li><li>评论<ul><li>发表评论</li></ul></li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>小程序本身就是 MVVM 架构的</li><li>与后端配合登录：wafer2-client-sdk</li><li>视图<ul><li>豆瓣 top250 列表<ul><li>按排名排列列表，显示基本信息</li><li>上拉加载 25 条数据，防止数据过多造成加载缓慢</li></ul></li><li>搜索<ul><li>搜索结果按排名排列，视图同首页</li></ul></li><li>电影详情<ul><li>显示电影详细信息，总看过数、收藏数、评论数</li><li>用户可进行评论</li></ul></li><li>个人中心<ul><li>头像、姓名、等级、看过数、收藏数、评论</li><li>等级数据综合看过电影数据和评论得出</li></ul></li><li>看过、收藏列表<ul><li>同首页视图</li></ul></li></ul></li></ul><p>前端目录结构</p><p><img src="https://pic.zhih.me/blog/posts/my-weapp-topmov/app.jpg" alt="前端目录结构"></p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul><li>采用 MVC 架构</li><li>采用 nodejs，使用 wafer-node-sdk</li><li>Web 框架：Koa2</li><li>请求体解析：koa-better-body</li><li>数据库（电影数据来自豆瓣）：<ul><li>toplist：top250 部分数据<ul><li>电影 id、影名、排名、评分、类型、时间、导演、主演、封面</li></ul></li><li>user：用户信息<ul><li>openid、session、已看、收藏</li></ul></li><li>mov：电影详情<ul><li>电影 id、详细描述、地区、原名、又名、已看数、收藏数、评论数</li></ul></li><li>comment：评论<ul><li>电影 id、openid、评论内容、评论时间、片名</li></ul></li></ul></li></ul><p>后端目录结构</p><p><img src="https://pic.zhih.me/blog/posts/my-weapp-topmov/server.jpg" alt="后端目录结构"></p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>HTML<br>CSS<br>JavaScript<br>Node.js<br>MySQL<br>Nginx</p><h2 id="动手做"><a href="#动手做" class="headerlink" title="动手做"></a>动手做</h2><h3 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h3><p>本地搭一个 https 服务器，因为小程序只支持 https，在微信公众平台设置域名等基础设置。</p><p>注意，要想扫码调试、预览，需要在路由器设置 hosts，把域名指向电脑的 IP。</p><h3 id="敲代码"><a href="#敲代码" class="headerlink" title="敲代码"></a>敲代码</h3><p>其实就是正常的 web 编程，小程序就是一个和 vue 很像的框架，数据是双向绑定的。因为接触过 vue 所以上手很简单。想想之前从节点驱动跳出，初次接触数据驱动，让我感觉很新奇也很爽。</p><p>首先是，微信开发者工具，之前第一次用的时候，真他妈难用，现在更新越来越好了，不过编辑器还是同样垃圾，敲代码还得用 VS code 或其他熟悉的编辑器，我用的是 sublime 因为各种插件啥的我都装好了，快捷键什么的都调的很舒服。开发者工具就拿来做调试吧。</p><p>顺便提一下，因为开发者工具里用的是 chrome 做调试工具，如果后端使用的是 nodejs，可以使用 node –inspect，配合调试。</p><p>然后，讲真，开发真的没什么可说的，官方的开发文档很详细，API 都很丰富，做一个电影列表没什么难度。</p><p>后端方面简单说一下，因为豆瓣的 API 有请求数限制，所以我冒昧的使用了自己的 VPS 做中转，做数据缓存。</p><p>另外，实现登录功能和登录态储存，使用的是 wafer-node-sdk，这个需要仔细看官方的说明。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><ol><li>开发者工具点击上传</li><li>微信公众平台提交审核</li><li>等个一两天就能审核完成</li></ol><p>注意，有些功能在个人认真的小程序是不能被审核通过的，比如我这里边的评论，我是通过先关闭评论功能，通过审核后再远程打开的😎，机智如我。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本来还打算写点什么的，后来发现，没啥可写，终究是肚子里墨水不够，技术积累还不行，得加油啊。</p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
            <tag> 全栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx配置HTTPS以及使用HTTP2服务器推送</title>
      <link href="/nginx-http2-https/"/>
      <url>/nginx-http2-https/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我的小博客在SSL Labs 的 <a href="https://www.ssllabs.com/ssltest/index.html" target="_blank" rel="noopener">SSL Server Test</a> 中得到了 A+ 的好成绩</p><p><img src="https://pic.zhih.me/blog/posts/nginx-http2-https/cover.jpg" alt="SSL Server Test"></p><p>虽然没搭建过什么大站，但是这几年也积累了不少经验，今天就说说在 Nginx 上配置 HTTPS、HTTP/2，并开启服务器推送。</p><p>很多人说做产品要追求用户体验，作为一个用户，我认为一个网站最重要的就是打开的速度。所以在自己搭网站的时候，一直痴心于提高网站的速度。</p><p>以我这个博客为例，自己移植并改写了主题，资源都进行了压缩，公共静态资源都用了公共 CDN，因为 VPS 的带宽只有可怜的 1M，所以图片资源都进行了压缩并存到了腾讯云 COS，使用 CDN 进行加速。这样的一堆加成之后，即使 VPS 每秒只能跑 128kb 的资源，也能快速的打开网站。</p><h2 id="优化什么"><a href="#优化什么" class="headerlink" title="优化什么"></a>优化什么</h2><p>web 性能优化的门路很多，有空我再另开一篇我对优化的见解说说，但是一般对于我博客这种静态站来说，真正影响速度的是，带宽、延迟、请求数、资源大小。带宽大、延迟低的 vps 贵，为减少服务器相关的开销，只能靠压缩资源和减少请求了。</p><p>网速慢的时候下载大文件特别操蛋，这大家都知道，那打开网页亦是如此，但速度不仅取决于客户端的网速，还有服务端的。既然搞不来网速快的服务器，那只能把文件减小咯，把什么 JS、CSS、图片都给压缩咯，这下总可以了吧。</p><p><strong>但是，压缩就足够了吗？</strong></p><p>不够，因为浏览器有个并发连接数限制，也就是说，浏览器对每个域名的并发请求是有限的，同一时间只能做几个请求，然后再等下一轮请求。具体到实际体验就是，当你的一个网页内需要加载的资源数量较多的时候，浏览器分几次才能把资源下载下来，这就影响到网页加载速度了。</p><p><strong>所以，该怎么办？</strong></p><p>减少请求数呗，很多时候都这样说，但是一般来说，减少请求数意味着对各种资源最内联处理，而缺点很明显，内联 CSS/JS 不好维护、内联图片不会有浏览器缓存、增大单个网页的体积，当然这些也不是绝对，至少以我这个静态博客来说，都是弊端。</p><p><strong>艹，一不小心都偏离重点了</strong></p><p>好吧，开始说说主题吧。</p><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p>关于是什么，干什么的，怎么来的，这些问题，自己去看<a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">维基百科</a>去，还有这一篇谷歌高性能 web 工程师写的文章：<a href="https://hpbn.co/http2" target="_blank" rel="noopener">https://hpbn.co/http2</a></p><p>我这里就简单说一下</p><p>一句话说就是，<strong>解决了上面遗留下来问题</strong></p><p>对于我们来说，提升体验的是它的这 3 个特性</p><ul><li><p>头压缩</p><ul><li>压缩请求头大小，减少请求时间</li></ul></li><li><p>请求和响应复用</p><ul><li>并行交错多个请求，不会阻塞任何请求</li><li>并行传输多个响应，而不会对任何一个进行阻塞</li><li>使用单个连接并行传送多个请求和响应</li><li>消除不必要的延迟并提高可用带宽的利用率</li></ul></li></ul><p><img src="https://pic.zhih.me/blog/posts/nginx-http2-https/multiplexing.jpg" alt="请求和响应复用"></p><ul><li>服务器推送<ul><li>除了对原始请求的响应之外，服务器还可以 向客户端推送额外的资源</li></ul></li></ul><p><img src="https://pic.zhih.me/blog/posts/nginx-http2-https/server-push.jpg" alt="服务器推送"></p><p><em>以上图片来自<a href="https://hpbn.co/http2" target="_blank" rel="noopener">https://hpbn.co/http2</a></em></p><p>如果把浏览器和服务器通信比作你和朋友聊天，那么在这个场景下，会是这样的</p><ul><li><p>HTTP1.1（目前主流协议）</p><ul><li>你发一句消息给朋友，需要等朋友回复你了才能发第二句</li><li>你不主动问候朋友，朋友不会理你</li></ul></li><li><p>HTTP2.0</p><ul><li>你可以一次发多条消息了，朋友也会一次性回复你</li><li>你的朋友会主动问候你</li></ul></li></ul><p>是不是美滋滋</p><h2 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h2><p>我的新文章，更详细的 HTTPS 配置，可以到这里查看</p><p><a href="https://zhih.me/make-your-website-support-tls1-3/">https://zhih.me/make-your-website-support-tls1-3/</a></p><p>本来这篇文章就是要写写，如何配置 HTTPS 的，想不到扯出这么多</p><p>关于为什么要配置 HTTPS，问你自己吧</p><h3 id="申请-SSL-证书"><a href="#申请-SSL-证书" class="headerlink" title="申请 SSL 证书"></a>申请 SSL 证书</h3><p>随着 HTTPS 的普及，出现了很多的免费证书，比如 Let’s Encrypt，但我打算之后再写一篇文章详细写写。</p><p>或者更方便的是到阿里云、腾讯云的后台申请免费的证书，也很简单。</p><h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><p>版本装最新的就好，如果服务器自带的源不够新，可以用 Nginx 的官方源，具体使用方式在他们的官网已经给出，不在详细说明。</p><p><a href="http://nginx.org/en/linux_packages.html" target="_blank" rel="noopener">http://nginx.org/en/linux_packages.html</a></p><h3 id="安装-OpenSSL"><a href="#安装-OpenSSL" class="headerlink" title="安装 OpenSSL"></a>安装 OpenSSL</h3><p>开启 HTTPS 需要 OpenSSL 版本 &gt;= 1.0.1，我用的 Debian9 自带 1.1.0</p><p>你可以使用 <code>openssl version</code> 这个命令查看，不够新的自行升级</p><h3 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h3><h4 id="HTTP-301-跳转-HTTPS"><a href="#HTTP-301-跳转-HTTPS" class="headerlink" title="HTTP 301 跳转 HTTPS"></a>HTTP 301 跳转 HTTPS</h4><p>大多浏览器默认访问 HTTP，所以我们需要让它跳转到 HTTPS 上</p><p>以我的博客为例</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> zhih.me www.zhih.me;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://zhih.me<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP2-和-HTTPS"><a href="#HTTP2-和-HTTPS" class="headerlink" title="HTTP2 和 HTTPS"></a>HTTP2 和 HTTPS</h3><p>目前所有支持 HTTP/2 的浏览器都是基于 TLS 1.2 协议之上构建 HTTP/2 的，所以要使用 HTTP/2 必须开启 HTTPS</p><p>以下是我博客服务器 HTTPS 部分的完整配置，gzip 压缩等其他设置我放到了 nginx.conf 里</p><p>我的配置可能会更新，可以去 <a href="https://zhih.me/make-your-website-support-tls1-3/">编译Nginx支持TLS1.3</a> 那篇帖子里看，一切以那里的为最新</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line">    <span class="attribute">server_name</span> zhih.me www.zhih.me;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$host</span> != zhih.me) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://zhih.me<span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">root</span>  /站点目录;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>       /ssl/zhih.me.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>   /ssl/zhih.me.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> <span class="string">'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256'</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">50m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">1d</span>;</span><br><span class="line">    <span class="attribute">ssl_session_tickets</span> <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">ssl_stapling</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_stapling_verify</span> <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">resolver</span> <span class="number">119.29.29.29</span> <span class="number">8.8.8.8</span> valid=<span class="number">300s</span>;</span><br><span class="line">    <span class="attribute">resolver_timeout</span> <span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">add_header</span> Strict-Transport-Security <span class="string">"max-age=31536000; includeSubDomains; preload"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>  index.html;</span><br><span class="line">        <span class="attribute">http2_push</span> /css/allinone.min.css;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><h4 id="开启-HTTP2"><a href="#开启-HTTP2" class="headerlink" title="开启 HTTP2"></a>开启 HTTP2</h4><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="section">listen</span> <span class="number">443</span> ssl http2;</span><br></pre></td></tr></table></figure><p>监听 443 端口，HTTPS 协议走这个端口，HTTP 走的是 80</p><p>只需要在 SSL 后面加上就能开启 HTTP2</p><blockquote><p>注意：我这配置里边的 301 跳转是从 <a href="http://www.zhih.me" target="_blank" rel="noopener">www.zhih.me</a> 跳转到 zhih.me，如果你不需要，可以不像这样设置</p></blockquote><h4 id="开启服务器推送"><a href="#开启服务器推送" class="headerlink" title="开启服务器推送"></a>开启服务器推送</h4><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> / &#123;</span><br><span class="line">        <span class="keyword">index</span>  <span class="keyword">index</span>.html;</span><br><span class="line">        http2_push /css/allinone.<span class="built_in">min</span>.css;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我这里把 <code>/css</code> 目录下的 <code>allinone.min.css</code> 文件添加了服务器推送</p><p>之后在浏览器开发者控制台里的效果就是这样的</p><p><img src="https://pic.zhih.me/blog/posts/nginx-http2-https/push.jpg" alt="服务器推送"></p><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h4><p><code>ssl_certificate</code> 是公钥，<code>ssl_certificate_key</code> 是私钥，后面写文件路径</p><p><code>ssl_protocols</code> 加密协议，Nginx 默认是 SSLv3 TLSv1 TLSv1.1 TLSv1.2，但是 SSLv3 目前还存在漏洞，不建议使用，而我做的比较激进，只保留了 TLSv1.2，因为我相信，能访问这个博客的人，用的浏览器都不会很低级。</p><p><code>ssl_ciphers</code> 加密算法，因为不同浏览器优先使用的算法不同，我们可以在服务端设置优先级和禁止使用的算法，并结合 <code>ssl_prefer_server_ciphers on</code> 来让浏览器优先选择我们设置好的。</p><p><code>ssl_session_cache</code> SSL 会话缓存</p><p><code>ssl_session_timeout</code> SSL 会话缓存过期时间</p><p><code>add_header Strict-Transport-Security max-age=15768000</code> 开启 HSTS，后面是缓存时间</p><h4 id="重启-Nginx"><a href="#重启-Nginx" class="headerlink" title="重启 Nginx"></a>重启 Nginx</h4><p>保存配置，重启 Nginx 生效</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h4><p>HTTPS 生效结果查看很简单，直接打开你的网站，看到浏览器前面有个锁头就行了</p><p>我们主要看 HTTP2 是否生效，使用 curl 命令，curl 需要支持 HTTPS HTTP2</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --http2 -I https://zhih.me</span><br></pre></td></tr></table></figure><p><img src="https://pic.zhih.me/blog/posts/nginx-http2-https/end.jpg" alt="效果"></p><p>教程写到这里就告一段落了，你可能就要问了，HTTP/2 加速了你的博客了吗？</p><p>一定程度上是的，但由于我用了 CDN，在自己服务器上请求的资源并不会很明显，博客上只有一个自定义样式表和基础的静态网页需要从我自己服务器上获取，其他的各种类库我都使用了 CDN，文章里的图片放到了腾讯云 COS 搭配 CDN 使用</p><p>每次有人访问时，请求了静态页面，HTTP2 的服务器推送会把自定义样式表推送过去，就减少了一次请求，用的 CDN 也启用了 HTTP2，所以可以在我这 1Mbps 小水管上实现 0.9s 打开 13 个请求、近 500kb 大小的页面</p><p><img src="https://pic.zhih.me/blog/posts/nginx-http2-https/blogspeed.jpg" alt="博客速度测试"></p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p>Moz 推荐的 HTTPS 配置（自动配置）：<a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/" target="_blank" rel="noopener">https://mozilla.github.io/server-side-tls/ssl-config-generator/</a></p><p>SSL Server Test：<a href="https://www.ssllabs.com/ssltest/index.html" target="_blank" rel="noopener">https://www.ssllabs.com/ssltest/index.html</a></p><p>不服跑个分</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>技术的升级迭代潜移默化的影响着大家的生活，从 1960 年 Ted Nelson 构思 HTTP 协议，到 1996 年 HTTP/1.0 被正式作为标准，再到 1997 年公布并一直沿用至今的 HTTP/1.1，可以说它是人类互联网的基石，2015 年发布了 HTTP2，它为网页性能而生，他以更快，更强，更安全的特性，逐渐被的被各大公司使用，相信全面普及 HTTPS/HTTP2 不会有太长的时间。</p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> https </tag>
            
            <tag> web优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Pyenv 管理PY的版本</title>
      <link href="/pyenv-usage/"/>
      <url>/pyenv-usage/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前几天使用 pip 安装腾讯云 COS 的命令行工具 <a href="https://github.com/tencentyun/coscmd" target="_blank" rel="noopener">coscmd</a> 的时候，MacOS 自带的 Python 和 pip 让我觉得不爽。</p><p>顺便装一下逼，上面提到的 <a href="https://github.com/tencentyun/coscmd" target="_blank" rel="noopener">coscmd</a> 我提交了几行代码，得到了 merge ，😏😏<strong>我特么也是给腾讯提交过代码的人</strong>😏😏。</p><p>首先是 pip ，我直接用 <code>easy_install</code> 安装的，在使用它安装 coscmd 时候，需要使用 sudo ，然后各种组件很难想我预想的那样顺利装上，总是需要加 sudo，应该是目录权限的原因。当然，这可能是我的锅，但是对于我来说，使用系统自带的环境是不好的，天知道哪天出错了会影响到什么，我更倾向于包管理器的那种安装方式，出问题就卸载从来。</p><p>然后是自带的 Python ，当然我并不是做 PY 开发的，但是接触一下总好，毕竟使用过太多的工具都是用 PY 编的，在之前使用的时候也遇到一些关于版本的问题，我之前还觉得自带了 Python 就美滋滋。然后想用 homebrew 直接自己装算了，但是有发现，这样也不灵活啊，有些时候要 py2.7、有的要 py3 ，那么问题来了，py 有没有和 nvm 一样的版本管理工具？</p><p><strong>废话，必须有的啊！</strong></p><p>这就是 <a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">Pyenv</a> 了。</p><blockquote><p>pyenv lets you easily switch between multiple versions of Python. It’s simple, unobtrusive, and follows the UNIX tradition of single-purpose tools that do one thing well.</p></blockquote><p>上面引用他们 github 上的话，翻译过来就是：装，就对了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>还是使用 homebrew 安装，关于 homebrew ，去我 <a href="https://zhih.me/make-macos-better/">上一篇文章</a> 看看。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure><p>安装好之后，我们还需要在打开 shell 的时候自动执行 pyenv 的初始化</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'eval "$(pyenv init -)"'</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>重启你的 shell 就生效了</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我这里只说说基本的使用方法，毕竟我只算是个推荐人，具体的高级用法，找他们的 Wiki 看去</p><h3 id="安装多个-Python-版本"><a href="#安装多个-Python-版本" class="headerlink" title="安装多个 Python 版本"></a>安装多个 Python 版本</h3><p>首先是找到需要装的 Python 版本号</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure><p>列出一堆各种的版本 Python ，要装哪个就记住版本号</p><p>比如说我这里要装个 2.7.14 和 3.6.5</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv install 2.7.14</span><br><span class="line">pyenv install 3.6.5</span><br></pre></td></tr></table></figure><p>这样就装上了，你就要问了，这不就和我用 homebrew 安装一样嘛，甚至它安装都调用了 homebrew ？</p><p>那下面就是 pyenv 真正起作用的时候了</p><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>实际使用中，我们可能不同的项目需要不同的版本，pyenv 可以给全局切换版本，也可以在给不同的目录设置不同的版本</p><h4 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv global 3.6.5</span><br><span class="line">pyenv <span class="built_in">rehash</span></span><br></pre></td></tr></table></figure><p>这下，使用 <code>python -V</code> 就能看到自己版本变成了 3.6.5</p><h4 id="当前目录"><a href="#当前目录" class="headerlink" title="当前目录"></a>当前目录</h4><p>要给项目单独设置 Python 版本，需要 cd 进入目录</p><p>例如我要给当前目录设置为 miniconda3-4.3.30</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv <span class="built_in">local</span> miniconda3-4.3.30</span><br><span class="line">pyenv <span class="built_in">rehash</span></span><br></pre></td></tr></table></figure><p>这样就可以了</p><h4 id="查看环境设置"><a href="#查看环境设置" class="headerlink" title="查看环境设置"></a>查看环境设置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv versions</span><br></pre></td></tr></table></figure><p>这个命令可以看自己装了哪几个版本，并且哪个目录给了哪个版本，写的清清楚楚</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>人生苦短，我选 Python</p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MacOS这样更好用</title>
      <link href="/make-macos-better/"/>
      <url>/make-macos-better/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我之所以选择使用 MacOS，是因为它是简洁高效的类 Unix 系统，对各种开发环境友好，并且近年来随着国内 Mac 的普及，各种应用软件也在 MacOS 上适配了，软件丰富度方面完全不用担心，并且 MacOS 下的软件更加的纯净简洁，不会像 Windows 下那样出现 “全家桶” 效应。</p><p>俗话说得好：工欲善其事，必先利其器</p><p>那么，刚装上一个新的系统，应该怎样去设置，让它更好用呢？</p><h2 id="1-系统设置"><a href="#1-系统设置" class="headerlink" title="1. 系统设置"></a>1. 系统设置</h2><h3 id="dock栏（程序坞）"><a href="#dock栏（程序坞）" class="headerlink" title="dock栏（程序坞）"></a>dock栏（程序坞）</h3><p>系统默认的 dock 栏是在底部的，在打开应用时会减少信息流可视面积，所以我们可以设置</p><ul><li>把它放到屏幕左边</li><li>调小图标</li><li>设置鼠标放在图标上时变大</li></ul><p>这样就可以省出更多的空间，并且按照从左到右的阅读习惯，放在右边比较合适。</p><p><img src="https://pic.zhih.me/blog/posts/make-macos-better/程序坞.jpg" alt="程序坞"></p><h3 id="finder（访达）"><a href="#finder（访达）" class="headerlink" title="finder（访达）"></a>finder（访达）</h3><p>finder 作为一个文件资源管理中心，一些小设置可以让你用的得心应手</p><ul><li>文件夹<ul><li>在用户目录里新建 <code>home</code>、<code>code</code> 目录</li></ul></li><li>工具栏<ul><li>去掉 <code>排列</code>，因为可以在文件夹里右键设置排列</li><li>添加 <code>删除</code>、<code>新建文件夹</code></li></ul></li><li>显示<ul><li>显示路径栏</li><li>显示状态栏</li></ul></li><li>侧边栏<ul><li>添加 <code>home</code> 目录</li><li>添加 <code>code</code> 目录</li></ul></li></ul><p><img src="https://pic.zhih.me/blog/posts/make-macos-better/访达.jpg" alt="访达.png"></p><h2 id="2-Xcode"><a href="#2-Xcode" class="headerlink" title="2. Xcode"></a>2. Xcode</h2><p>Xcode 是 MacOS 下重要的 IDE，你要是开发苹果系的原生 App，需要它，而我们更多是需要他的命令行工具</p><p>首先，在<a href="https://itunes.apple.com/cn/app/xcode/id497799835?mt=12" target="_blank" rel="noopener">App Store</a>安装Xcode。</p><p>Xcode 提供了编译软件必备的 <code>Xcode Command Line Tools</code>，它包含了 GCC 编译器，在装完 Xcode 之后我们需要执行一下命令安装它</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>他会提示安装，按照说明操作就可以了。</p><h2 id="3-Homebrew"><a href="#3-Homebrew" class="headerlink" title="3. Homebrew"></a>3. Homebrew</h2><p>用过 Linux 的都知道包管理器，Debian 系用的 dpkg、红帽系用的 rpm，而 MacOS 下最受追捧的就是 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 了，它可以让我们安装和更新应用程序或库，是个大杀器。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 Homebrew 需要前面提到的 <code>Xcode Command Line Tools</code>，之后 Homebrew 所执行的编译包的任务全都依靠它。</p><p>在终端输入命令以下回车就能进行安装了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure><p>在安装完成后执行以下命令，诊断一下有没有什么错误，或者 Homebrew 需要你做什么样的设置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew doctor</span><br></pre></td></tr></table></figure><p>brew 就是 Homebrew 的包管理命令了，用法类似 debian 的 apt-get</p><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>Homebrew 默认的源服务器在国外，这样我们在国内使用的时候速度可能比较慢，阿里云提供了镜像源，我们可以使用以下命令替换</p><p>注意，以下命令为Zsh终端的配置，所以要执行 <code>brew install zsh</code> 安装zsh。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换brew.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.aliyun.com/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换homebrew-core.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用生效</span></span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换homebrew-bottles:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>homebrew 的用法和其它包管理器一样，如果你使用过，那么这步你可以不看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装软件包</span></span><br><span class="line">brew insatll 包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">brew search 包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">brew uninstall 包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已安装列表</span></span><br><span class="line">brew list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取新列表</span></span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级软件包</span></span><br><span class="line">brew upgrade</span><br></pre></td></tr></table></figure><h2 id="4-快速查看"><a href="#4-快速查看" class="headerlink" title="4. 快速查看"></a>4. 快速查看</h2><p>QuickLook 是 MacOS 中相当高效的功能，按一下空格键就可以预览文件，不比打开文件浏览，很方便快捷，它自带的功能可能没有很全，有些文件无法预览，那么就需要给它装上插件。</p><p>这里是一些常用的插件： <a href="https://github.com/sindresorhus/quick-look-plugins#manually" target="_blank" rel="noopener">https://github.com/sindresorhus/quick-look-plugins#manually</a></p><p>可以直接使用 homebrew 进行安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlimagesize webpquicklook suspicious-package quicklookase qlvideo</span><br></pre></td></tr></table></figure><h2 id="5-终端"><a href="#5-终端" class="headerlink" title="5. 终端"></a>5. 终端</h2><p>终端绝对是 MacOS 秒杀 Windows 的第一大杀器了，当然，有很多人会推荐使用 iTerm2 之类的第三方终端，就我个人而言，系统自带的就足够，不用再去装那些功能丰富的终端，适合自己的才是第一生产力，学习怎么去用的时间，可以写一个 <a href="https://zhih.me/onmp-installation/">onmp</a> 了。</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>终端的偏好设置你随便设置，怎么适合怎么来，我在这里只推荐一个必须设置的项，<a href="https://github.com/tonsky/FiraCode" target="_blank" rel="noopener">FiraCode字体</a>，你可以去他们的 github 页看看，相信你一定会爱上它。</p><h3 id="Zsh"><a href="#Zsh" class="headerlink" title="Zsh"></a>Zsh</h3><p>我们在上面已经提到过 zsh，它是个令人感到惊艳的 shell，关于它，自行搜索看看吧。</p><p>使用 homebrew 安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install zsh</span><br></pre></td></tr></table></figure><p>不出意外，现在就安装上了</p><p>前面finder设置里新建 <code>home</code> 目录的目的是防止每次进终端进行文件下载，或者进行其他操作时，把用户目录搞得一团糟</p><p>所以现在还要设置打开终端自动进入 <code>home</code> 目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure><p>在最后添加 <code>cd ~/home</code></p><h3 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h3><p><a href="http://ohmyz.sh" target="_blank" rel="noopener">Oh My Zsh</a> 是 zsh 的一个扩展工具集，提供了丰富的扩展功能，没有他，zsh 将不再完整</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>Oh My Zsh 有丰富的插件，你可以在 <code>~/.zshrc</code> 里的 <code>plugins</code> 字段添加插件</p><p>这里我给几个推荐的插件，在 <a href="https://github.com/zsh-users" target="_blank" rel="noopener">https://github.com/zsh-users</a> 这里能找到后面 3 个安装方法，前面的不用其他安装方式</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">plugins=(git autojump colored-man-pages colorize pip <span class="keyword">python</span> osx brew zsh-autosuggestions zsh-<span class="keyword">syntax</span>-highlighting <span class="keyword">history</span>-substring-<span class="built_in">search</span>)</span><br></pre></td></tr></table></figure><h2 id="6-Git"><a href="#6-Git" class="headerlink" title="6. Git"></a>6. Git</h2><p>我不是针对谁，我只想说，不用 git 的程序员都是辣鸡</p><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>安装成功后可以使用 <code>git --version</code> 看到git版本号</p><h3 id="连接-GitHub"><a href="#连接-GitHub" class="headerlink" title="连接 GitHub"></a>连接 GitHub</h3><p><a href="https://help.github.com/articles/set-up-git/" target="_blank" rel="noopener">GitHub官方设置教程</a></p><p>我这里就把它的简化一下</p><p>github 可以通过 https 和 ssh 连接，我这里推荐使用 https 连接，原因是设置简单、不易被防火墙挡</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"github用户名"</span></span><br><span class="line">git config --global user.email <span class="string">"github注册邮箱"</span></span><br></pre></td></tr></table></figure><p>这些配置信息会存到 <code>~/.gitconfig</code> 里</p><p>只是这样设置，每次使用都会提示输入密码，所以要告诉 Git 使用 osxkeychain helper 全局 credential.helper 配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper osxkeychain</span><br></pre></td></tr></table></figure><p>下一次克隆需要密码的 HTTPS URL 时，系统会提示您输入用户名和密码，并授予访问 OSX 钥匙串的权限。完成此操作后，用户名和密码将存储在您的钥匙串中，并且不需要再次将它们输入到 Git 中。</p><p>至此，大功告成</p><h2 id="7-结语"><a href="#7-结语" class="headerlink" title="7. 结语"></a>7. 结语</h2><p>MacOS 作为一个对开发者友好的系统，还有很对技巧等着大家发掘，并且每个人的习惯都是不同的，而 MacOS 也容纳了大家的不同，提供了大家个性化设置的基础，相信在你的调教下，它会成为你手中的大杀器。</p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一键开启MacOS HiDPI</title>
      <link href="/one-key-hidpi/"/>
      <url>/one-key-hidpi/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>作为一个黑苹果用户，追求黑果的体验是当然的，当各个硬件都驱动完善后，要做的就是细节的优化了，毕竟装上是拿来用的，可不能因为体验差苦了自己啊😂。机器毕竟便宜，从第一视觉上最重要的就是屏幕了，当然自带的屏幕素质没法改变，除非换屏了，然而换屏又违背了省钱的初衷，于是只能通过 UI 上的改变来提升体验了。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>项目地址：<a href="https://github.com/xzhih/one-key-hidpi" target="_blank" rel="noopener">https://github.com/xzhih/one-key-hidpi</a></p><p> 此脚本的目的是为中低分辨率的屏幕开启 HiDPI 选项，并且具有原生的 HiDPI 设置，不需要 RDM 软件即可在系统显示器设置中设置</p><p>MacOS 的 dpi 机制和 win 下不一样，比如 1080p 的屏幕在 win 下有 125%、150% 这样的缩放选项，而同样的屏幕在 MacOS 下，缩放选项里只是单纯的调节分辨率，这就使得在默认分辨率下字体和 UI 看起来很小，降低分辨率又显得模糊。</p><p>同时，此脚本也可以通过注入修补后的 EDID 修复闪屏，或者睡眠唤醒后的闪屏问题，当然这个修复因人而异</p><p>开机的第二阶段 logo 总是会稍微放大，因为分辨率是仿冒的</p><p>设置：</p><p><img src="https://pic.zhih.me/blog/posts/one-key-hidpi/hidpi-setting.jpg" alt="HiDPI效果.png"></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在终端输入以下命令回车即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/xzhih/one-key-hidpi/master/hidpi-zh.sh)</span>"</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.zhih.me/blog/posts/one-key-hidpi/run.jpg" alt="运行"></p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>如果使用此脚本后，开机无法进入系统，请到恢复模式中或使用 clover 的 <code>-x</code> 安全模式进入系统 ，使用终端删除 /System/Library/Displays/Contents/Resources/Overrides 下删除显示器 VendorID 对应的文件夹，并把 backup 文件夹中的备份复制出来。</p><p>具体命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Volumes/你的系统盘/System/Library/Displays/Contents/Resources/Overrides</span><br><span class="line">VendorID=$(ioreg -l | grep <span class="string">"DisplayVendorID"</span> | awk <span class="string">'&#123;print $8&#125;'</span>)</span><br><span class="line">Vid=$(<span class="built_in">echo</span> <span class="string">"obase=16;<span class="variable">$VendorID</span>"</span> | bc | tr <span class="string">'A-Z'</span> <span class="string">'a-z'</span>)</span><br><span class="line">rm -rf ./DisplayVendorID-<span class="variable">$Vid</span></span><br><span class="line">cp -r ./backup/* ./</span><br></pre></td></tr></table></figure><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>黑苹果安装教程</title>
      <link href="/hackintosh-install-guide/"/>
      <url>/hackintosh-install-guide/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在燃7000 的群里发现还有很多小伙伴进群，挺震惊的，毕竟这本子这么久了还能保持一定的热度，但是群里的教程比较老旧，很多内容已经不适合现在的新系统，于是就有了这个教程。</p><p>黑果安装的教程大同小异，就是各个机型的配置不一样，从而导致EFI不一样，理论上讲，配置和燃7000相同或相近的机器都能按照这个教程安装好。</p><blockquote><p>其他机型的小伙伴可以到我的黑苹果合集里找找，可能会有合适你的 EFI<br><a href="https://zhih.me/hackintosh/">https://zhih.me/hackintosh/</a></p></blockquote><h2 id="视频版"><a href="#视频版" class="headerlink" title="视频版"></a>视频版</h2><p>B站：<a href="https://www.bilibili.com/video/av21503652" target="_blank" rel="noopener">https://www.bilibili.com/video/av21503652</a></p><p>YouTube：<a href="https://youtu.be/IZCF3E_oQB8" target="_blank" rel="noopener">https://youtu.be/IZCF3E_oQB8</a></p><h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h2><p>至少 8G 容量的U盘</p><p>分区精灵 <a href="http://www.diskgenius.cn" target="_blank" rel="noopener">http://www.diskgenius.cn</a></p><p>黑果小兵的 <a href="https://zhih.me/hackintosh/#/OS-images">MacOS 镜像</a></p><p>镜像写入工具：<a href="https://www.balena.io/etcher/" target="_blank" rel="noopener">Etcher</a></p><p><del>transmac 链接: <a href="https://pan.baidu.com/s/15QmZZLtRU1ZwMi7uCYKC-g" target="_blank" rel="noopener">https://pan.baidu.com/s/15QmZZLtRU1ZwMi7uCYKC-g</a> 密码: 8dpe</del></p><h2 id="2-分配硬盘ESP分区"><a href="#2-分配硬盘ESP分区" class="headerlink" title="2. 分配硬盘ESP分区"></a>2. 分配硬盘ESP分区</h2><p>硬盘分区表类型必须为 GUID，ESP 分区必须大于 200M，我建议给个 220M</p><p><img src="https://pic.zhih.me/blog/posts/hackintosh-install-guide/ESP分区.jpg" alt="ESP分区"></p><p>分出你想要装 MacOS 的分区，大小你自己定，格式随便，因为安装时要抹盘</p><h2 id="3-写入镜像"><a href="#3-写入镜像" class="headerlink" title="3. 写入镜像"></a>3. 写入镜像</h2><p>写入镜像现在可以使用更好的工具 <a href="https://www.balena.io/etcher/" target="_blank" rel="noopener">Etcher</a>，当然 transmac 也是可以用的</p><h3 id="第一种方法-Etcher"><a href="#第一种方法-Etcher" class="headerlink" title="第一种方法 Etcher"></a>第一种方法 Etcher</h3><ol><li>安装后打开 Etcher</li><li>选择镜像</li><li>选择 U 盘</li><li>等待写入完成</li></ol><p><strong>这样就可以了</strong>，是不是很简单</p><h3 id="第二种方法-transmac"><a href="#第二种方法-transmac" class="headerlink" title="第二种方法 transmac"></a>第二种方法 transmac</h3><p><strong>格式化</strong></p><p>以管理员身份运行 transmac，<kbd>右键</kbd>点击你的U盘，选择 <code>Format Disk for Mac</code>，全选择确认然后等它格式化完，win10 可能会提示要想使用U盘必须对其格式化，点取消。</p><p><img src="https://pic.zhih.me/blog/posts/hackintosh-install-guide/格式化.jpg" alt="格式化"></p><p><strong>写入</strong></p><p>再次<kbd>右键</kbd>点击 U 盘，选择 <code>Restore with Disk Image</code>，选择镜像点击 OK，静静等待写入完成</p><p><img src="https://pic.zhih.me/blog/posts/hackintosh-install-guide/写入镜像.jpg" alt="写入镜像"></p><p>写入完成，win 可能还会提示一些格式化之类的，不用理会</p><h2 id="4-其他设置"><a href="#4-其他设置" class="headerlink" title="4. 其他设置"></a>4. 其他设置</h2><h3 id="BIOS-设置"><a href="#BIOS-设置" class="headerlink" title="BIOS 设置"></a>BIOS 设置</h3><p>重启进入 BIOS，设置硬盘 AHCI、关闭安全启动，保存退出</p><p><img src="https://pic.zhih.me/blog/posts/hackintosh-install-guide/BIOS设置1.jpg" alt="BIOS设置"></p><p><img src="https://pic.zhih.me/blog/posts/hackintosh-install-guide/BIOS设置2.jpg" alt="BIOS设置"></p><h3 id="U盘启动"><a href="#U盘启动" class="headerlink" title="U盘启动"></a>U盘启动</h3><p>再次重启，进入启动项选择（ dell 是在显示 logo 时按 <kbd>F12</kbd>）</p><p>选择你的U盘</p><p><img src="https://pic.zhih.me/blog/posts/hackintosh-install-guide/U盘启动1.jpg" alt="U盘启动"></p><p>如果你的没显示，可以在 BIOS 里添加</p><p><img src="https://pic.zhih.me/blog/posts/hackintosh-install-guide/U盘启动2.jpg" alt="U盘启动"></p><h2 id="5-安装"><a href="#5-安装" class="headerlink" title="5. 安装"></a>5. 安装</h2><p>在 clover 设置里选择 config 为 <code>config_HD615_620_630_640_650.plist</code></p><p><img src="https://pic.zhih.me/blog/posts/hackintosh-install-guide/clover启动设置.jpg" alt="clover启动设置"></p><p>返回选择 MacOS 安装引导项</p><h3 id="抹盘"><a href="#抹盘" class="headerlink" title="抹盘"></a>抹盘</h3><p>以上不出意外，就能看到 MacOS 的恢复模式了</p><p>进入磁盘工具</p><p>选择你要安装到的分区，点击抹掉，选择格式为 <code>MacOS扩展（日志式）</code>，抹掉</p><p><img src="https://pic.zhih.me/blog/posts/hackintosh-install-guide/抹盘.jpg" alt="抹盘"></p><p>抹盘出现错误的，一般是分区所在硬盘的 ESP 分区不足 200M 导致的</p><h3 id="安装-MacOS"><a href="#安装-MacOS" class="headerlink" title="安装 MacOS"></a>安装 MacOS</h3><p>退出磁盘工具，选择安装 MacOS</p><p>之后就能正常安装了，具体的我就不上图了，想看过程就去看视频版的吧</p><p>安装会有 3 个阶段</p><ul><li><p>第一阶段，程序把文件写入硬盘，然后会自动重启，选择U盘引导进入 clover，再次设置 config，退出选择新出现的引导项</p></li><li><p>第二阶段，程序继续进行系统安装，完成后会自动重启，同样需要选择U盘引导和 config 设置</p></li><li><p>第三阶段，系统安装完成，进行一些自定义设置，进入系统</p></li></ul><h2 id="6-更换EFI，实现硬盘引导和其他驱动"><a href="#6-更换EFI，实现硬盘引导和其他驱动" class="headerlink" title="6. 更换EFI，实现硬盘引导和其他驱动"></a>6. 更换EFI，实现硬盘引导和其他驱动</h2><p>安装好系统后，一些硬件是没有驱动的，这是就需要用替换 EFI 了，而且之前的 EFI 是镜像自带的，并且在U盘里，现在我们要用硬盘引导</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>下载 <a href="https://mackie100projects.altervista.org/download-clover-configurator/" target="_blank" rel="noopener">Clover Configurator</a></p><p><img src="https://pic.zhih.me/blog/posts/hackintosh-install-guide/下载CloverConfigurator.jpg" alt="Clover Configurator"></p><p>下载 <a href="https://zhih.me/dell-7460-7560-hackintosh">冰水的EFI</a></p><p><img src="https://pic.zhih.me/blog/posts/hackintosh-install-guide/冰水的EFI.jpg" alt="冰水的EFI"></p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>打开 Clover Configurator，点击 <code>Mount EFI</code> ，挂载安装磁盘上 ESP 分区</p><p>打开分区，把你的机型所对应的 EFI 文件夹扔到分区里</p><p><img src="https://pic.zhih.me/blog/posts/hackintosh-install-guide/替换.jpg" alt="替换"></p><p>可以拔掉U盘重启了</p><h2 id="7-后续"><a href="#7-后续" class="headerlink" title="7. 后续"></a>7. 后续</h2><p>启动默认进 win 的，可以在 BIOS 里设置 clover 启动项为第一位</p><p>亮度无法调节的，可以使用 kext utility 重建缓存，重启生效</p><p>字体太小？可以使用我的 HIDPI 脚本开启缩放</p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hackintosh </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我是如何在128M内存的vps上安装lnmp的</title>
      <link href="/lnmp-on-128m-ram-vps/"/>
      <url>/lnmp-on-128m-ram-vps/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>封面那张图和这篇文章无关😂，那是之前在学校的时候拍的，一台 64M 古董大脑壳装 win me，然后玩三维弹球🤪 2333</p><p><img src="https://pic.zhih.me/blog/posts/lnmp-on-128m-ram-vps/winme.jpg" alt="三维弹球"></p><p>作为一个整天折腾 VPS 的博主，手里少不了各种便宜的低配小鸡，今天我要祭出我那经常被 BAN 😒的 128M 内存小鸡，为大家写一篇小内存 VPS 安装 lnmp 的教程，并且，我要让它把 WordPress 跑起来。</p><p>先上配置：<br>CPU：Intel(R) Xeon(R) CPU X5560 @ 2.80GHz 单核<br>内存：128M<br>硬盘：2GB<br>系统：debian-8.0-x86_64<br>虚拟化：openVZ</p><p>可以说这小鸡是相当极限了，当然我还有一台传家宝 64M 内存的，但是在上面装 lnmp 遇到了一些麻烦，就放弃了😂</p><h2 id="一、软件源"><a href="#一、软件源" class="headerlink" title="一、软件源"></a>一、软件源</h2><p>由于配置太低，lnmp 所需的 Nginx MySQL PHP 要是用编译的方式安装，在过程中基本就宕机了，所以这里才用的是 apt 的方式进行安装。</p><p>在执行以下操作前，建议先运行一下命令，更新和安装一些包，以防出错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade</span><br><span class="line">apt-get install curl wget</span><br></pre></td></tr></table></figure><h3 id="1-添加软件源"><a href="#1-添加软件源" class="headerlink" title="1. 添加软件源"></a>1. 添加软件源</h3><p>系统是 debian8，自带源内没有 PHP7，所以添加一个 <a href="http://www.dotdeb.org" target="_blank" rel="noopener">dotdeb</a> 源，它里面有 debian7、debian8 的各种软件包，同时他们也提供世界各地的<a href="https://www.dotdeb.org/mirrors/" target="_blank" rel="noopener">镜像</a>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/apt/sources.list</span><br><span class="line"><span class="comment"># 在 sources.list 里添加两行 (deb 和 deb-src)</span></span><br></pre></td></tr></table></figure><p>我的 vps 在美帝，所以添加了他们的美国镜像</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">deb</span> http://mirrors.asnet.<span class="keyword">am</span>/dotdeb/ jessie <span class="keyword">all</span></span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.asnet.<span class="keyword">am</span>/dotdeb/ jessie <span class="keyword">all</span></span><br></pre></td></tr></table></figure><p>如果你直接从官网复制过来，或者是你的系统是 debian7，记得修改网址后面的版本名。</p><h3 id="2-安装-GnuPG-密匙"><a href="#2-安装-GnuPG-密匙" class="headerlink" title="2. 安装 GnuPG 密匙"></a>2. 安装 GnuPG 密匙</h3><p>GPG主要是实现官方发布的包的签名。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.dotdeb.org/dotdeb.gpg</span><br><span class="line">sudo apt-key add dotdeb.gpg</span><br></pre></td></tr></table></figure><h3 id="3-源添加完毕"><a href="#3-源添加完毕" class="headerlink" title="3. 源添加完毕"></a>3. 源添加完毕</h3><p>运行 <code>apt-get update &amp;&amp; apt-get upgrade</code>，现在你应该能从 dotdeb 上获取软件了。</p><h2 id="二、软件包"><a href="#二、软件包" class="headerlink" title="二、软件包"></a>二、软件包</h2><h3 id="1-Nginx"><a href="#1-Nginx" class="headerlink" title="1. Nginx"></a>1. Nginx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install nginx -y</span><br></pre></td></tr></table></figure><p>打开浏览器，输入你的 IP，能显示 <code>Welcome to nginx!</code>，就说明安装成功了。</p><h3 id="2-PHP7"><a href="#2-PHP7" class="headerlink" title="2. PHP7"></a>2. PHP7</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install php7.0 php7.0-cgi php7.0-cli php7.0-fpm php7.0-mysql php7.0-odbc php7.0-opcache -y</span><br></pre></td></tr></table></figure><p>以上我只安装了几个 module，如有需要，自己安装其他的。</p><p>安装成功后，运行 <code>php -v</code> 可以看到 PHP 的版本信息。</p><h3 id="3-MySQL"><a href="#3-MySQL" class="headerlink" title="3. MySQL"></a>3. MySQL</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install mysql-client mysql-server -y</span><br></pre></td></tr></table></figure><p>输入命令后，会进行安装，过程中会有输入密码的提示框，按提示操作即可。</p><p>运行 <code>mysql -u root -p</code>，输入密码，能进入 MySQL 就说明装上了。</p><h2 id="三、安装-WordPress"><a href="#三、安装-WordPress" class="headerlink" title="三、安装 WordPress"></a>三、安装 WordPress</h2><p>至此 lnmp 已经安装完毕了，我们先看看相关的管理命令再安装 WordPress。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动|停止|重启</span></span><br><span class="line">/etc/init.d/nginx start|stop|restart</span><br><span class="line">/etc/init.d/php7.0-fpm start|stop|restart</span><br><span class="line">/etc/init.d/mysql start|stop|restart</span><br></pre></td></tr></table></figure><p>好了，咱们开始安装 WordPress</p><p>这部分我就不多说了，配置教程之类的很多，WP官网的安装文档也相当清晰。</p><p>其实就是以下步骤：</p><ol><li>创建 Nginx 配置文件</li><li>在 MySQL 里创建数据库</li><li>下载、解压 WordPress 程序包</li><li>进入网页安装</li></ol><p>跑得动没啥，就是看看这小鸡的承载能力，我这里使用 ab 命令对首页进行压力测试，并且首页也就一篇文章列表，情况如下图：</p><p><img src="https://pic.zhih.me/blog/posts/lnmp-on-128m-ram-vps/压力测试.jpg" alt="压力测试"></p><p>在做100个并发，访问10000次的测试中，在进行到第7143个请求的时候，小鸡爆了，完全无法访问，过了一会才恢复过来，看来对它的要求不能太高啊😂。</p><p>当然，使用WP也要使用静态化插件才能提高承载能力，我就懒得试了</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实这篇文章就是给小鸡跑个 lnmp，给它点压力，我过过手瘾，也证实一下 128M 的小内存vps是有能力搭建访问量少的 WP 博客的。</p><p>但是，既然内存这么小，何不用 hexo 那种静态博客呢。</p><p>这篇文章仅作为新手安装 lnmp 教程，照顾那些低价买了低配置 vps 的同学，祝你们折腾愉快。</p><p>如果你想购买 vps，可以看看 <a href="https://m.do.co/c/5ddae9064d7f" target="_blank" rel="noopener">DigitalOcean</a></p><p>这里是我的优惠链接：<a href="https://m.do.co/c/5ddae9064d7f" target="_blank" rel="noopener">https://m.do.co/c/5ddae9064d7f</a>，通过这个链接注册，你可以得到10美元用来购买vps。</p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> lnmp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>戴尔燃7000黑苹果EFI</title>
      <link href="/dell-7460-7560-hackintosh/"/>
      <url>/dell-7460-7560-hackintosh/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>简单说下我的电脑配置：<br>CPU: i5-7200u<br>显卡: HD620 / 940MX<br>RAM: 2x4G DDR4 2400MHz (但是这个U只支持2133MHz，不过也是可以了)<br>硬盘: SATA3 500g 机械硬盘 / M.2 SATA3 128g SSD<br>声卡: ALC 3246<br>网卡: DW 1830（原本是一张牙膏厂的垃圾卡，就更换了黑果能驱动的卡）</p><p>在买这台电脑之前就听说过 hackintosh，也就是黑苹果。但是都没有尝试过，因为一般的笔记本黑起来麻烦多多，很难做到“可用”状态，而这台电脑不仅有两个内存插槽、一个 M.2 接口（不支持 nvme）、一个 SATA3 接口，还有一个可更换的网卡，很适合用来黑。</p><p>这是我第一次动手装黑果，所以首先大量的看帖，各种逛<a href="http://bbs.pcbeta.com/forum.php?gid=86" target="_blank" rel="noopener">远景论坛</a>，在各种爬楼之后，心里终于有点底了，然后感谢同机型的 @设为主页，他应该是第一个在这台机子装上的人，他贡献了最初版的 EFI。我花了一个下午终于装上😀，其实感觉不是难装，是出现问题的时候不知道怎么解决，还好我没遇到太多问题。</p><p>后来各种找驱动，学习了很多东西，就自己尝试配置 EFI，很简单的就配置出了这个 EFI。其他机型，配置相同或者大致相同的同学可以尝试使用这个 EFI。</p><blockquote><p>其他机型的小伙伴可以到我的黑苹果合集里找找，可能会有合适你的 EFI<br><a href="https://zhih.me/hackintosh/">https://zhih.me/hackintosh/</a></p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>此合集适用于戴尔燃 7000 系列第一第二代型号为 7460/7560/7472/7572 的笔记本电脑<br>EFI 可直接用于安装和日常使用</p><p>项目地址：<a href="https://github.com/xzhih/dell-7460-7560-hackintosh" target="_blank" rel="noopener">https://github.com/xzhih/dell-7460-7560-hackintosh</a></p><p>SSDT hotpatch 来自<a href="https://github.com/RehabMan/OS-X-Clover-Laptop-Config" target="_blank" rel="noopener">RehabMan</a></p><p>文件列表：</p><ol><li>EFI (必须)</li><li><a href="https://github.com/xzhih/one-key-hidpi" target="_blank" rel="noopener">HIDPI 已转移到单独的仓库</a> (可选)</li><li>网卡驱动 (可选)</li><li>黑果小兵的 ALCPlugFix (详细说明<a href="https://github.com/daliansky/ALCPlugFix/blob/master/README.md" target="_blank" rel="noopener">来源传送门</a>)</li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1-EFI"><a href="#1-EFI" class="headerlink" title="1. EFI"></a>1. EFI</h3><p>安装时（不保证能顺利安装）：使用 transmac 写入镜像至 U 盘后，拷贝 EFI 到 U 盘 ESP 分区中，重启按 <kbd>F12</kbd> 选择 U 盘启动即可开始安装</p><p>具体安装教程请看<a href="https://zhih.me/hackintosh-install-guide/">我的教程</a></p><p>日常使用：安装好系统后，使用 <code>clover configurator</code> 挂载 MacOS 所在硬盘的 ESP 分区，把 EFI 拷贝进去，重启按 <kbd>F2</kbd> 进入 BIOS 设置此引导为首选，保存重启即可</p><h3 id="2-声卡、耳机"><a href="#2-声卡、耳机" class="headerlink" title="2. 声卡、耳机"></a>2. 声卡、耳机</h3><p>声卡驱动都已经有了，只需要进入 <code>黑果小兵的ALCPlugFix</code> 这个文件夹，双击 <code>install...</code> 运行即可，可以解决唤醒无声、耳机无声、耳机杂音等问题</p><h3 id="3-一键开启HIDPI并注入EDID"><a href="#3-一键开启HIDPI并注入EDID" class="headerlink" title="3. 一键开启HIDPI并注入EDID"></a>3. 一键开启HIDPI并注入EDID</h3><p>此一键命令可开启接近原生的 HIDPI 设置，不需要RDM软件即可在系统显示器设置中设置</p><p>仓库地址：<a href="https://github.com/xzhih/one-key-hidpi" target="_blank" rel="noopener">一键开启 HIDPI</a></p><p>效果：</p><p><img src="https://pic.zhih.me/blog/posts/one-key-hidpi/hidpi-setting.jpg" alt="设置.png"></p><h3 id="4-网卡驱动"><a href="#4-网卡驱动" class="headerlink" title="4. 网卡驱动"></a>4. 网卡驱动</h3><p>机器自带的无线网卡无法驱动，只能购买可驱动的网卡更换，推荐购买 <code>dw1560/dw1830</code> 这两款网卡，需要注意的是燃系列有个超燃版也就是没有独显的版本，它因为主板结构不同不能安装 dw1830，另外 dw1830 是 3 天线网卡，在购买时可向商家索要一根 <code>7~15cm</code> 的天线，安装时将第三根天线放置在 HDD 下的开槽处防止金属屏蔽信号</p><p>文件夹内有两个网卡的驱动，自行将里面的驱动拷贝到 <code>EFI/clover/kext/other</code> 中</p><h3 id="5-触摸板手势"><a href="#5-触摸板手势" class="headerlink" title="5. 触摸板手势"></a>5. 触摸板手势</h3><h4 id="1-先在设置-gt-键盘-gt-修饰键里设置恢复到默认"><a href="#1-先在设置-gt-键盘-gt-修饰键里设置恢复到默认" class="headerlink" title="1. 先在设置-&gt;键盘-&gt;修饰键里设置恢复到默认"></a>1. 先在设置-&gt;键盘-&gt;修饰键里设置恢复到默认</h4><p>默认 <kbd>win</kbd> 对应 <kbd>cmd</kbd> 键，<kbd>alt</kbd> 对应 <kbd>opt</kbd> 键，我习惯这样</p><h4 id="2-在快捷键里设置以下键位"><a href="#2-在快捷键里设置以下键位" class="headerlink" title="2. 在快捷键里设置以下键位"></a>2. 在快捷键里设置以下键位</h4><p><img src="https://pic.zhih.me/blog/posts/dell-7460-7560-hackintosh/触控板快捷键.jpg" alt="快捷键.png"></p><h4 id="3-触控板驱动-手势："><a href="#3-触控板驱动-手势：" class="headerlink" title="3. 触控板驱动+手势："></a>3. 触控板驱动+手势：</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">轻触和双指右键在设置 -&gt; 触控板里设置</span><br><span class="line">三指轻触：打开通知</span><br><span class="line">四指轻触：最小化应用到 dock 栏</span><br><span class="line">三指向上轻扫：Mission Control</span><br><span class="line">三指向下轻扫：应用程序窗口</span><br><span class="line">三指向左轻扫：切换到下一个 <span class="meta">space</span></span><br><span class="line">三指向右轻扫：切换到上一个 <span class="meta">space</span></span><br><span class="line">四指向上轻扫：launchpad</span><br><span class="line">四指向下轻扫：显示桌面</span><br></pre></td></tr></table></figure><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hackintosh </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo主题casper使用教程</title>
      <link href="/hexo-casper-usage/"/>
      <url>/hexo-casper-usage/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>这是本人移植自 <a href="https://github.com/TryGhost/Casper" target="_blank" rel="noopener">Ghost’s Casper theme</a> 的一个 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 主题。</p><p>项目地址 <a href="https://github.com/xzhih/hexo-theme-casper" target="_blank" rel="noopener">https://github.com/xzhih/hexo-theme-casper</a></p><p>DEMO <a href="https://xzhih.github.io/hexo-theme-casper/" target="_blank" rel="noopener">https://xzhih.github.io/hexo-theme-casper/</a></p><h2 id="项目来由"><a href="#项目来由" class="headerlink" title="项目来由"></a>项目来由</h2><p>最近搞了个博客，用的是 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> ，发现了很多不错的主题，在寻找主题的过程中发现了另一个博客程序 <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a> 。它的新版默认主题很和我的胃口，但是在github上搜索一通后，发现只有老版本的被移植到了 hexo，于是想自己动手把它移植过来，看了官方文档后发现hexo的主题还是相当好制作的，用了几天弄好了。当然，功能还不是很完善。</p><p>经过几次的修改更新，现在已经比较完善了，大多功能都是主题集成的，不需要再安装插件</p><p>下面我就说一下主题的使用方法。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>文章封面图（在首页文章摘要上显示）</li><li>文章特色图（在文章详细页面上置顶）</li><li>自定义菜单</li><li>自定义 favicon, logo, 头部背景, 作者头像</li><li>社交链接 ( 现在支持 github、哔哩哔哩、YouTube、微博、推特、脸书 )</li><li>共三个插件（最新文章、分类、标签云）</li><li>内容目录</li><li>代码高亮</li><li>响应式网页设计</li><li>懒加载</li><li>主题集成本地搜索</li><li>Valine 评论系统</li><li>Baidu 链接提交、Google Analytics</li><li>Service Worker</li></ul><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/xzhih/hexo-theme-casper.git themes/hexo-casper</span><br></pre></td></tr></table></figure><h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>把hexo配置文件 <code>_config.yml</code> 里的 <code>theme</code> 字段内容改为 <code>hexo-casper</code> 。</p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>建议先备份一下在执行下面的操作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/casper </span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="添加统一的文章模板参数"><a href="#添加统一的文章模板参数" class="headerlink" title="添加统一的文章模板参数"></a>添加统一的文章模板参数</h3><p>把下面的内容加入到 <code>scaffolds/post.md</code>,</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover_img:</span>     <span class="comment"># 在文章摘要上显示</span></span><br><span class="line"><span class="attr">feature_img:</span>   <span class="comment"># 在文章详细页面上置顶</span></span><br><span class="line"><span class="attr">description:</span>   <span class="comment"># 文章描述</span></span><br><span class="line"><span class="attr">keywords:</span>      <span class="comment"># 关键字</span></span><br></pre></td></tr></table></figure><h3 id="valine-评论系统"><a href="#valine-评论系统" class="headerlink" title="valine 评论系统"></a>valine 评论系统</h3><p>使用方法请到他的<a href="https://valine.js.org" target="_blank" rel="noopener">官网</a>查看，并结合下面的配置文件详细添加appID和appKey</p><p><strong>添加关于页面</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>编辑 <code>themes/hexo-casper/_config.yml</code> 设置你想显示出来的特性</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Config</span></span><br><span class="line"><span class="attr">rss:</span>            <span class="comment"># link</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="attr">https://i.loli.net/2017/11/26/5a19c0b50432e.png</span></span><br><span class="line"><span class="attr">blog_logo:</span> </span><br><span class="line"><span class="attr">header_image:</span> <span class="attr">https://i.loli.net/2017/11/26/5a19c56faa29f.jpg</span></span><br><span class="line"><span class="attr">bio:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">a</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">post_toc:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 菜单</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  About:</span> <span class="string">/about</span></span><br><span class="line"><span class="attr">  Archives:</span> <span class="string">/archives</span></span><br><span class="line">  <span class="comment"># 其他的可以按照上面的模板添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者</span></span><br><span class="line"><span class="attr">author_image:</span>   <span class="comment"># 链接</span></span><br><span class="line"><span class="attr">author_bio:</span>     <span class="comment"># 描述</span></span><br><span class="line"><span class="attr">author_location:</span> <span class="comment"># 地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 社交链接</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line"><span class="attr">  facebook:</span> <span class="attr">https://www.facebook.com</span></span><br><span class="line"><span class="attr">  twitter:</span> <span class="attr">https://www.twitter.com</span></span><br><span class="line"><span class="attr">  twitter:</span> <span class="attr">https://twitter.com</span></span><br><span class="line"><span class="attr">  facebook:</span> <span class="attr">https://facebook</span></span><br><span class="line"><span class="attr">  telegram:</span></span><br><span class="line"><span class="attr">  bilibili:</span></span><br><span class="line"><span class="attr">  youtube:</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 插件（显示在网站底部）</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line"><span class="attr">  recent_posts:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  category:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  tagcloud:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 这是个简洁的主题，我认为3个就够了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章图片相册（点击图片可以放大）</span></span><br><span class="line"><span class="comment"># https://github.com/sachinchoolur/lightgallery.js</span></span><br><span class="line"><span class="attr">lightgallery:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 懒加载</span></span><br><span class="line"><span class="comment"># 首页已经默认开启，其他页面在此开启</span></span><br><span class="line"><span class="comment"># https://github.com/dinbror/blazy</span></span><br><span class="line"><span class="attr">lazyload:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索功能</span></span><br><span class="line"><span class="attr">local_search:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Valine 评论系统</span></span><br><span class="line"><span class="comment"># https://valine.js.org</span></span><br><span class="line"><span class="attr">comment:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki </span></span><br><span class="line"><span class="attr">  verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line"><span class="attr">  appId:</span> <span class="comment"># your leancloud application appid</span></span><br><span class="line"><span class="attr">  appKey:</span> <span class="comment"># your leancloud application appkey</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># comment box placeholder</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line"><span class="attr">  pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PWA </span></span><br><span class="line"><span class="comment"># 你需要在 hexo 目录的 source 文件夹里创建一个 manifest.json 文件</span></span><br><span class="line"><span class="attr">manifest:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">service_workers:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">navColor:</span> <span class="string">'3c484e'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu 链接提交</span></span><br><span class="line"><span class="attr">baidu:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Analytics</span></span><br><span class="line"><span class="attr">googleAnalytics:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">GA_TRACKING_ID:</span> <span class="string">UA-XXXXXXXXXX-1</span></span><br></pre></td></tr></table></figure><h2 id="本地搜索功能参考"><a href="#本地搜索功能参考" class="headerlink" title="本地搜索功能参考"></a>本地搜索功能参考</h2><p><a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">https://github.com/wzpan/hexo-generator-search</a><br><a href="https://github.com/SuperKieran/hexo-generator-search-zip" target="_blank" rel="noopener">https://github.com/SuperKieran/hexo-generator-search-zip</a></p><h2 id="源主题的版权声明和-License"><a href="#源主题的版权声明和-License" class="headerlink" title="源主题的版权声明和 License"></a>源主题的版权声明和 License</h2><p><a href="https://github.com/TryGhost/Casper/blob/master/LICENSE" target="_blank" rel="noopener">https://github.com/TryGhost/Casper/blob/master/LICENSE</a></p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何在路由器上格式化U盘、硬盘</title>
      <link href="/format-Upan-partition/"/>
      <url>/format-Upan-partition/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本教程适用于梅林、padavan、LEDE（openwrt）等固件</p><p>以下具体方法都基于 ext4，NTFS 相关错误不做回答</p><p>使用ssh连接路由器，把U盘插到路由器上</p><p>我们需要在命令行进行以下4步操作：</p><h2 id="安装fdisk"><a href="#安装fdisk" class="headerlink" title="安装fdisk"></a>安装fdisk</h2><p>一般梅林、Padavan 固件都会自带的，不用安装，如果没有则按照下面给出的命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install fdisk</span><br><span class="line"><span class="comment"># 输出Configuring fdisk. 并且没有错误</span></span><br><span class="line"><span class="comment"># fdisk就安装好了</span></span><br></pre></td></tr></table></figure><h2 id="查看你的设备"><a href="#查看你的设备" class="headerlink" title="查看你的设备"></a>查看你的设备</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l </span><br><span class="line"><span class="comment"># 这里先输出系统分区之类的不用管，外置设备一般在最后</span></span><br><span class="line">Disk /dev/sda: 30.7 GB, 30752000000 bytes</span><br><span class="line">64 heads, 32 sectors/track, 29327 cylinders</span><br><span class="line">Units = cylinders of 2048 * 512 = 1048576 bytes</span><br><span class="line">Device Boot      Start         End      Blocks  Id System</span><br><span class="line">/dev/sda1               2       29327    30029824  83 Linux</span><br></pre></td></tr></table></figure><p>上面的信息注意看到和你的存储大小一样的设备，我的是 <code>/dev/sda</code>，在它里面有个 <code>/dev/sda1</code>的分区</p><h2 id="删除分区、新建分区"><a href="#删除分区、新建分区" class="headerlink" title="删除分区、新建分区"></a>删除分区、新建分区</h2><p>先卸载 U 盘，如果提示 <code>No such file or directory</code> 没关系，说明本来就没挂载上</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># padavan、梅林可以执行以下这个推出 usb</span></span><br><span class="line">ejusb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他固件，或者梅林使用以上命令无效，则可以使用这个命令卸载分区</span></span><br><span class="line">umount /dev/sda1</span><br></pre></td></tr></table></figure><p>然后分区</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sda <span class="comment"># 这是你的设备別打成分区</span></span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.29.2).</span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): d </span><br><span class="line"><span class="comment"># 输入d回车，我只有一个分区，它自动选择了，如果你有多个分区，可以多次使用d</span></span><br><span class="line">Selected partition 1</span><br><span class="line">Partition 1 has been deleted.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n <span class="comment"># 输入n会车，创建分区</span></span><br><span class="line">Partition <span class="built_in">type</span></span><br><span class="line">p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">e   extended (container <span class="keyword">for</span> logical partitions)</span><br><span class="line"></span><br><span class="line">Select (default p): p <span class="comment"># 选择p</span></span><br><span class="line">Partition number (1-4, default 1): <span class="comment"># 输入 1 回车</span></span><br><span class="line">First sector (2048-2065023, default 2048): <span class="comment"># 回车</span></span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-2065023, default 2065023): <span class="comment"># 回车</span></span><br><span class="line">Created a new partition 1 of <span class="built_in">type</span> <span class="string">'Linux'</span> and of size 1007.3 MiB.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w <span class="comment"># 输入 w 回车，保存并退出</span></span><br><span class="line">The partition table has been altered.</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure><p>经过以上的操作，你可以用 <code>fdisk -l</code> 命令查看U盘上是否只有一个 Linux 分区</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l </span><br><span class="line"><span class="comment"># 找到你的设备 可以看到ID为83就对了</span></span><br><span class="line">Disk /dev/sda: 30.7 GB, 30752000000 bytes</span><br><span class="line">64 heads, 32 sectors/track, 29327 cylinders</span><br><span class="line">Units = cylinders of 2048 * 512 = 1048576 bytes</span><br><span class="line">Device Boot      Start         End      Blocks  Id System</span><br><span class="line">/dev/sda1               2       29327    30029824  83 Linux</span><br></pre></td></tr></table></figure><h2 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h2><p>分区已经有了，现在开始格式化</p><p>用 <code>mkfs.ext4</code> 命令格式化，并且设置卷标为 onmp</p><p><strong>注意</strong>，如果下面的命令提示 <code>/dev/sda1 is mounted</code>，则需要先卸载 U 盘，和分区前卸载的方法一样</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 -m 0 -L onmp /dev/sda1 </span><br><span class="line"><span class="comment"># 如果你的硬盘比较大，256G以上的话，是下面这个命令：</span></span><br><span class="line"><span class="comment"># mkfs.ext4 -m 0 -L ONMP -T largefile /dev/sda1</span></span><br><span class="line"></span><br><span class="line">mke2fs 1.42.8 (20-Jun-2013)</span><br><span class="line">Filesystem label=onmp</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">1880480 inodes, 7507456 blocks</span><br><span class="line">0 blocks (0.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=0</span><br><span class="line">230 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8176 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,</span><br><span class="line">        4096000</span><br><span class="line"></span><br><span class="line">Allocating group tables: <span class="keyword">done</span></span><br><span class="line">Writing inode tables: <span class="keyword">done</span></span><br><span class="line">Creating journal (32768 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这样，U盘就被格式化完了，拔插 U 盘可以重新挂载，或者你想用以下命令挂载也行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/onmp</span><br><span class="line">mount -t ext4 /dev/sda1 /mnt/onmp</span><br></pre></td></tr></table></figure><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> 路由器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ONMP安装教程</title>
      <link href="/onmp-installation/"/>
      <url>/onmp-installation/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前用过极路由 1s，刷了恩山 H大的固件，发现内置了 web 环境，没想到一个路由器都能跑的动 LNMP。我之前最极限的尝试就是在一个 4刀3年 的 sentris ovz 小鸡上跑过 WordPress ，那台小鸡 配置很低，只有 64M 的内存😂。不过 LNMP 流畅运行的因素挺多，PHP 吃 CPU、MySQL 吃 IO，不同的程序表现也不一样。那台极路由被我折腾了没两下就放弃了在上面搭网站，毕竟性能太低。</p><p>后来我上车了斐讯 K2P，拿回来花了一个晚上改好了 32+512+usb，刷的是灯大的硬改固件，少了H大固件的里面的丰富拓展，感觉都不对了，k2p 既然硬改了，那就好好玩它，之前不是嫌弃极 1s 的性能不足嘛，现在 K2P 比起它来说，性能强了一些，运存大、CPU强、还是 USB3.0，那就写个一键安装 web 环境吧，于是就有了这个项目。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>ONMP 是一个 web 环境快速安装脚本，适用于安装了 <a href="https://entware.net/" target="_blank" rel="noopener">Entware</a> 的路由器，目前已经在 Padavan、LEDE（openwrt）、梅林上测试成功。</p><p>和 LNMP 有什么不同？<br>LNMP 代表的是：Linux 系统下 Nginx/MySQL/PHP 这种网站服务器架构，而为了区分路由器环境的不同，使用的 ONMP 这个命名，本质还是 LNMP。</p><p>项目地址：<a href="https://github.com/xzhih/ONMP" target="_blank" rel="noopener">https://github.com/xzhih/ONMP</a></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>此脚本不仅自动化安装 web 环境，还内置了一些好用的网站程序一键免配置快速安装。</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ONMP</span>内置了以下程序的一键安装：</span><br><span class="line">(<span class="number">1</span>) <span class="selector-tag">phpMyAdmin</span>（数据库管理工具）</span><br><span class="line">(<span class="number">2</span>) <span class="selector-tag">WordPress</span>（使用最广泛的<span class="selector-tag">CMS</span>）</span><br><span class="line">(<span class="number">3</span>) <span class="selector-tag">Owncloud</span>（经典的私有云）</span><br><span class="line">(<span class="number">4</span>) <span class="selector-tag">Nextcloud</span>（<span class="selector-tag">Owncloud</span>团队的新作，美观强大的个人云盘）</span><br><span class="line">(<span class="number">5</span>) <span class="selector-tag">h5ai</span>（优秀的文件目录）</span><br><span class="line">(<span class="number">6</span>) <span class="selector-tag">Lychee</span>（一个很好看，易于使用的<span class="selector-tag">Web</span>相册）</span><br><span class="line">(<span class="number">7</span>) <span class="selector-tag">Kodexplorer</span>（可道云<span class="selector-tag">aka</span>芒果云在线文档管理器）</span><br><span class="line">(<span class="number">8</span>) <span class="selector-tag">Netdata</span>（详细得惊人的服务器监控面板）</span><br><span class="line">(<span class="number">9</span>) <span class="selector-tag">Typecho</span> (流畅的轻量级开源博客程序)</span><br><span class="line">(<span class="number">10</span>) <span class="selector-tag">Z-Blog</span> (体积小，速度快的PHP博客程序)</span><br><span class="line">(<span class="number">11</span>) <span class="selector-tag">DzzOffice</span> (开源办公平台)</span><br></pre></td></tr></table></figure><h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><h3 id="1-安装-Entware"><a href="#1-安装-Entware" class="headerlink" title="1. 安装 Entware"></a>1. 安装 Entware</h3><p>Entware 是一个适用于嵌入式系统的软件包库，使用 opkg 包管理系统进行管理，现在在官方的源上已经有超过2000个软件包了，可以说是非常的丰富</p><p>不同的固件，安装方式都不一样，请认准安装方式（自己是什么固件总该懂得吧😂）</p><p><a href="https://zhih.me/Padavan-entware/">在 Padavan 上使用 Entware</a></p><p><a href="https://zhih.me/LEDE-entware">在 LEDE 上使用 Entware</a></p><p><a href="https://zhih.me/Merlin-entware">在梅林上使用 Entware</a></p><h3 id="2-安装onmp"><a href="#2-安装onmp" class="headerlink" title="2. 安装onmp"></a>2. 安装onmp</h3><p>一键命令，复制-&gt;粘贴-&gt;回车</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -kfsSL https://raw.githubusercontent.com/xzhih/ONMP/master/oneclick.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>一长串的复制如果出错，可以按照以下给出的命令，一步步进行安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 entware 挂载目录</span></span><br><span class="line"><span class="built_in">cd</span> /opt &amp;&amp; opkg install wget unzip </span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载软件包</span></span><br><span class="line">wget --no-check-certificate -O /opt/onmp.zip https://github.com/xzhih/ONMP/archive/master.zip </span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">unzip /opt/onmp.zip</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /opt/onmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">chmod +x ./onmp.sh </span><br><span class="line">./onmp.sh</span><br></pre></td></tr></table></figure><p>要是正常运行到脚本，会出现下面的情景，选1安装即可</p><p><img src="https://pic.zhih.me/blog/posts/onmp-installation/安装.jpg" alt="安装"></p><p>正常安装中要是出现错误，会有错误信息，根据提示操作，目前得到的大多数反馈都是网络问题，因为 entware 的源在国外，而且他们的管理者说之前受到了来自亚洲的 DDOS，所以对这边限流了，速度较慢。遇到这种情况，可以去看看剧，没准回来的时候就好了😄</p><p>安装成功得到的结果是这样的</p><p><img src="https://pic.zhih.me/blog/posts/onmp-installation/安装成功.jpg" alt="安装成功"></p><p>如果你也是和上图一样，那么恭喜你，成功的安装上了 ONMP，你可以尽情的玩耍了</p><h2 id="ONMP-详细使用教程"><a href="#ONMP-详细使用教程" class="headerlink" title="ONMP 详细使用教程"></a>ONMP 详细使用教程</h2><h3 id="基本命令："><a href="#基本命令：" class="headerlink" title="基本命令："></a>基本命令：</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">管理：onmp <span class="built_in">open</span></span><br><span class="line">启动、停止、重启：onmp <span class="built_in">start</span>|<span class="built_in">stop</span>|restart</span><br><span class="line">查看网站列表：onmp list</span><br></pre></td></tr></table></figure><h3 id="设置数据库密码："><a href="#设置数据库密码：" class="headerlink" title="设置数据库密码："></a>设置数据库密码：</h3><p>输入 <code>onmp open</code> 后选择3，会提示 <code>Enter password:</code> ，这个时候要输入当前数据库的密码，比如我初始设置的数据库密码是 123456，回车后要是密码正确，会提示输入你要设置的新密码，回车后会提示再次输入确认。也就是，一次旧密码，两次新密码。</p><p>这个位置很简单，但是很多人都说改不了密码，其实是没看提示，没输入旧密码，所以我写清楚一些。</p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> onmp </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在Padavan 上使用Entware</title>
      <link href="/Padavan-entware/"/>
      <url>/Padavan-entware/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Entware 是一个适用于嵌入式系统的软件包库，使用 opkg 包管理系统进行管理，现在在官方的源上已经有超过 2000 个软件包了，可以说是非常的丰富</p><p>官方地址：<a href="https://entware.net/" target="_blank" rel="noopener">Entware</a></p><h2 id="U盘、硬盘格式化（可选）"><a href="#U盘、硬盘格式化（可选）" class="headerlink" title="U盘、硬盘格式化（可选）"></a>U盘、硬盘格式化（可选）</h2><p>我们的设备本身的储存较少，而且如果哪天崩了，数据还有找不回的风险，所以我们一般把软件包和程序安装到 U 盘之类的外置设备上，所以需要对它进行格式化，以下教程全基于 ext4 分区格式，NTFS 格式我个人不推荐使用</p><p>格式化教程：<a href="https://zhih.me/format-Upan-partition">如何在路由器上格式化U盘、硬盘</a></p><h2 id="安装-Entware"><a href="#安装-Entware" class="headerlink" title="安装 Entware"></a>安装 Entware</h2><h3 id="1-新建-opt-文件夹"><a href="#1-新建-opt-文件夹" class="headerlink" title="1. 新建 opt 文件夹"></a>1. 新建 opt 文件夹</h3><ul><li><p>如果你是在电脑上格式化的 U 盘，并且知道怎么在电脑上读取 ext4 分区，那么在 ext4 分区的根目录新建一个 opt 文件夹</p></li><li><p>或者你可以把 U 盘插到路由器上，开启 samba 并通过电脑访问 samba，在 U 盘下创建 opt 文件夹</p></li><li><p>如果你上面的不会，并且按照我的教程在路由器上格式化 U 盘，还可以按照以下做法</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ejusb</span><br><span class="line">mkdir /media/onmp</span><br><span class="line">mount -t ext4 /dev/sda1 /media/onmp</span><br><span class="line"><span class="comment"># /dev/sda1 是你的 ext4 分区</span></span><br><span class="line"></span><br><span class="line">mkdir /media/onmp/opt</span><br></pre></td></tr></table></figure><p>这样就创建好 opt 文件夹了，之后装的所有东西都会在里面</p><h3 id="2-开启-Entware"><a href="#2-开启-Entware" class="headerlink" title="2. 开启 Entware"></a>2. 开启 Entware</h3><p>先卸载 U 盘</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ejusb</span><br></pre></td></tr></table></figure><p>然后在路由器管理页打开 Entware</p><p><img src="https://pic.zhih.me/blog/posts/Padavan-entware/在Padavan上使用entware.jpg" alt="在 Padavan 上使用 entware "></p><p>拔下 U 盘再重新插入，等一小会儿</p><h3 id="3-查看是否成功挂载-opt"><a href="#3-查看是否成功挂载-opt" class="headerlink" title="3. 查看是否成功挂载 /opt"></a>3. 查看是否成功挂载 /opt</h3><p>进入 shell，输入 <code>df -h</code>，看到 <code>/opt</code> 挂载了就对了</p><p><img src="https://pic.zhih.me/blog/posts/Padavan-entware/查看是否成功挂载.jpg" alt="查看是否成功挂载 /opt"></p><p>如果 opt 没挂载，说明没安装上，请保证 opt 文件夹已经创建正确，确认无误，则可以进 shell 输入 <code>opkg.sh</code> 回车安装</p><p>如果使用固件自带脚本出现错误，可以尝试使用以下脚本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O - http://bin.entware.net/mipselsf-k3.4/installer/generic.sh | /bin/sh</span><br></pre></td></tr></table></figure><h3 id="测试-opkg-命令"><a href="#测试-opkg-命令" class="headerlink" title="测试 opkg 命令"></a>测试 opkg 命令</h3><p>以上步骤之后，不出意外就装上了，我们现在可以测试一下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opkg update</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://zhih.me/LEDE-entware/">在 LEDE 上使用 Entware</a></p><p><a href="https://zhih.me/Merlin-entware/">在梅林上使用 Entware</a></p><p>ONMP 是一个 web 环境快速安装脚本，适用于安装了 <a href="https://entware.net/" target="_blank" rel="noopener">Entware</a> 的路由器，目前已经在 Padavan、LEDE（openwrt）、梅林上测试成功。</p><p><a href="https://zhih.me/onmp-installation/">ONMP 安装教程</a></p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> onmp </tag>
            
            <tag> entware </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在LEDE上使用Entware</title>
      <link href="/LEDE-entware/"/>
      <url>/LEDE-entware/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Entware 是一个适用于嵌入式系统的软件包库，使用 opkg 包管理系统进行管理，现在在官方的源上已经有超过2000个软件包了，可以说是非常的丰富</p><p>官方地址：<a href="https://entware.net/" target="_blank" rel="noopener">Entware</a></p><h2 id="U盘、硬盘格式化（可选）"><a href="#U盘、硬盘格式化（可选）" class="headerlink" title="U盘、硬盘格式化（可选）"></a>U盘、硬盘格式化（可选）</h2><p>我们的设备本身的储存较少，而且如果哪天崩了，数据还有找不回的风险，所以我们一般把软件包和程序安装到U盘之类的外置设备上，所以需要对它进行格式化，NTFS 格式我个人不推荐使用</p><p>格式化教程：<a href="https://zhih.me/format-Upan-partition">如何在路由器上格式化U盘、硬盘</a></p><h2 id="一键安装"><a href="#一键安装" class="headerlink" title="一键安装"></a>一键安装</h2><p>用以下命令可以实现一键安装，此脚本只支持 ext4 分区</p><p>运行命令，选择要安装到的分区，等待安装完成</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -kfsSL https://raw.githubusercontent.com/xzhih/ONMP/master/lede-ent.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>如果提示找不到 curl 命令，可以用下面这个方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">wget -c -O https://raw.githubusercontent.com/xzhih/ONMP/master/lede-ent.sh</span><br><span class="line">chmod +x ./lede-ent.sh</span><br><span class="line">./lede-ent.sh</span><br></pre></td></tr></table></figure><p>一键安装如果出错，或者重启后 Entware 失效，可以使用下面的手动安装</p><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><p>手动安装可一键安装不同，一键安装使用软连接 opt 的方式，而手动则是以挂载点的方式，可以说更稳定</p><h3 id="U盘挂载"><a href="#U盘挂载" class="headerlink" title="U盘挂载"></a>U盘挂载</h3><p>分区、格式都没问题之后，开始挂载</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/onmp</span><br></pre></td></tr></table></figure><h4 id="挂载方法1"><a href="#挂载方法1" class="headerlink" title="挂载方法1"></a>挂载方法1</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t ext4 /dev/sda1 /mnt/onmp</span><br><span class="line"><span class="comment"># 这样就挂载上了</span></span><br><span class="line"></span><br><span class="line">df -h</span><br><span class="line">Filesystem                Size      Used Available Use% Mounted on</span><br><span class="line">/dev/sda1               975.5M      2.5M    906.6M   0% /mnt/onmp</span><br><span class="line"><span class="comment"># 可以看到已经挂载</span></span><br></pre></td></tr></table></figure><h4 id="挂载方法2（推荐）"><a href="#挂载方法2（推荐）" class="headerlink" title="挂载方法2（推荐）"></a>挂载方法2（推荐）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/fstab <span class="comment"># 按一下i编辑文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加下面这一行</span></span><br><span class="line">/dev/sda1 /mnt/onmp ext4 defaults 0 1 </span><br><span class="line"><span class="comment"># 按一下Esc再输入冒号`:`，输入wq回车保存</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以后每次要挂载就直接输入这个命令</span></span><br><span class="line">mount -a</span><br></pre></td></tr></table></figure><p>开机自动挂载</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/rc.local <span class="comment"># 编辑，vim基本用法和上面一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在exit 0之前添加以下命令，开机后会自动执行挂载</span></span><br><span class="line">mount -a</span><br></pre></td></tr></table></figure><h3 id="安装和使用-Entware"><a href="#安装和使用-Entware" class="headerlink" title="安装和使用 Entware"></a>安装和使用 Entware</h3><h4 id="1-挂载opt"><a href="#1-挂载opt" class="headerlink" title="1. 挂载opt"></a>1. 挂载opt</h4><p>在U盘上创建一个空的 opt 文件夹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/onmp/opt</span><br></pre></td></tr></table></figure><p>在系统根目录创建 opt 文件夹，并绑定U盘的 opt 文件夹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /opt</span><br><span class="line">mount -o <span class="built_in">bind</span> /mnt/onmp/opt /opt</span><br><span class="line"><span class="comment"># 可以用 mount 或 df -h 命令查看是否挂载成功</span></span><br></pre></td></tr></table></figure><h4 id="2-运行-Entware-安装命令"><a href="#2-运行-Entware-安装命令" class="headerlink" title="2. 运行 Entware 安装命令"></a>2. 运行 Entware 安装命令</h4><p>不同的 CPU 平台有不同的命令，可以使用 <code>uname -m</code> 命令查看平台</p><ul><li>armv5</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O - http://bin.entware.net/armv5sf-k3.2/installer/generic.sh | /bin/sh</span><br></pre></td></tr></table></figure><ul><li>armv7</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O - http://bin.entware.net/armv7sf-k3.2/installer/generic.sh | /bin/sh</span><br></pre></td></tr></table></figure><ul><li>armv8 (aarch64)</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O - http://bin.entware.net/aarch64-k3.10/installer/generic.sh | /bin/sh</span><br></pre></td></tr></table></figure><ul><li>x86-64</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O - http://bin.entware.net/x64-k3.2/installer/generic.sh | /bin/sh</span><br></pre></td></tr></table></figure><ul><li>MIPS</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O - http://bin.entware.net/mipselsf-k3.4/installer/generic.sh | /bin/sh</span><br></pre></td></tr></table></figure><p>在输入命令之后之后会自己跑起来，出现以下结果就代表成功，没成功的记得把U盘上的opt文件夹清空再来</p><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Info</span>: Congratulations!</span><br><span class="line"><span class="keyword">Info</span>: <span class="keyword">If</span> there are no errors above <span class="keyword">then</span> Entware was successfully initialized.</span><br></pre></td></tr></table></figure><h4 id="3-开机启动"><a href="#3-开机启动" class="headerlink" title="3. 开机启动"></a>3. 开机启动</h4><p>编辑 <code>/etc/rc.local</code> 将以下代码加在 <code>exit 0</code> 之前，<code>mount -a</code> 之后</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">mkdir</span> -p /<span class="meta">opt</span></span><br><span class="line"><span class="symbol">mount</span> -o <span class="keyword">bind </span>/mnt/onmp/<span class="meta">opt</span> /<span class="meta">opt</span></span><br><span class="line">/<span class="meta">opt</span>/etc/init.d/rc.unslung start</span><br></pre></td></tr></table></figure><h4 id="4-环境变量"><a href="#4-环境变量" class="headerlink" title="4. 环境变量"></a>4. 环境变量</h4><p>编辑 <code>/etc/profile</code> 在他的最后加入以下代码</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">. /<span class="keyword">opt</span>/etc/<span class="keyword">profile</span></span><br></pre></td></tr></table></figure><p>这样开机之后将会添加 <code>/opt/bin</code> 和 <code>/opt/sbin</code> 到环境变量 PATH 里</p><p><strong>注意</strong>，<code>.</code> 的后面有一个空格，不是连着的</p><h4 id="5-重启"><a href="#5-重启" class="headerlink" title="5. 重启"></a>5. 重启</h4><p>重启之后，可以使用一下命令检查是否成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 可以看到已经有/opt的路径了</span></span><br><span class="line">/opt/bin:/opt/sbin:/usr/sbin:/usr/bin:/sbin:/bin </span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 `/opt` 挂载情况</span></span><br><span class="line">df -h</span><br><span class="line">/dev/sda1               975.5M     13.9M    895.2M   2% /mnt/onmp <span class="comment"># U盘挂载成功</span></span><br><span class="line">/dev/sda1               975.5M     13.9M    895.2M   2% /opt <span class="comment"># opt挂载成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># opkg 更新数据</span></span><br><span class="line">opkg update</span><br><span class="line">Downloading http://pkg.entware.net/binaries/x86-64/Packages.gz </span><br><span class="line">Updated list of available packages <span class="keyword">in</span> /opt/var/opkg-lists/packages <span class="comment"># 成功</span></span><br></pre></td></tr></table></figure><p>经过以上步骤，已经可以从 <code>Entware</code> 上进行下载安装包并安装到U盘上</p><p>这下可以享受丰富的软件包，还不占用内部储存空间，非常适合LEDE软路由<br>我的 onmp 一键包也可以在 LEDE 上使用了</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>每次升级固件后如果失效了，重新设置开机启动和环境变量即可</p><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p><a href="https://zhih.me/Merlin-entware/">在梅林上使用Entware</a></p><p><a href="https://zhih.me/Padavan-entware/">在Padavan上使用entware</a></p><p>ONMP 是一个 web 环境快速安装脚本，适用于安装了 <a href="https://entware.net/" target="_blank" rel="noopener">Entware</a> 的路由器，目前已经在 Padavan、LEDE（openwrt）、梅林上测试成功。</p><p><a href="https://zhih.me/onmp-installation/">ONMP 安装教程</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Entware/Entware/wiki/Install-on-Synology-NAS" target="_blank" rel="noopener">Install on Synology NAS</a></p><p><a href="https://bitbucket.org/padavan/rt-n56u/wiki/EN/HowToConfigureEntware" target="_blank" rel="noopener">How To Configure Routers Asus RT-N56U/RT-N65U For Entware Usage</a></p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LEDE </tag>
            
            <tag> onmp </tag>
            
            <tag> entware </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在梅林上使用Entware</title>
      <link href="/Merlin-entware/"/>
      <url>/Merlin-entware/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Entware 是一个适用于嵌入式系统的软件包库，使用 opkg 包管理系统进行管理，现在在官方的源上已经有超过 2000 个软件包了，可以说是非常的丰富</p><p>官方地址：<a href="https://entware.net/" target="_blank" rel="noopener">Entware</a></p><h2 id="U盘、硬盘格式化（可选）"><a href="#U盘、硬盘格式化（可选）" class="headerlink" title="U盘、硬盘格式化（可选）"></a>U盘、硬盘格式化（可选）</h2><p>我们的设备本身的储存较少，而且如果哪天崩了，数据还有找不回的风险，所以我们一般把软件包和程序安装到U盘之类的外置设备上，所以需要对它格式化为 ext4，NTFS 格式不推荐使用</p><p>格式化教程：<a href="https://zhih.me/format-Upan-partition">如何在路由器上格式化U盘、硬盘</a></p><h2 id="U盘挂载（可选）"><a href="#U盘挂载（可选）" class="headerlink" title="U盘挂载（可选）"></a>U盘挂载（可选）</h2><p>梅林固件可以在插入磁盘的时候自动识别文件系统并挂载，所以说是相当方便了，一般我们都不需要执行这一步，不过有些固件可能还没有很完善，所以我给出以下一种挂载的方法，供参考。</p><p>分区、格式都没问题之后，开始挂载</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/sda1</span><br><span class="line">mount -t ext4 /dev/sda1 /mnt/sda1/</span><br><span class="line"><span class="comment"># 这样就挂载上了</span></span><br><span class="line">df -h</span><br><span class="line">Filesystem                Size      Used Available Use% Mounted on</span><br><span class="line">/dev/sda1               975.5M      2.5M    906.6M   0% /tmp/mnt/sda1</span><br><span class="line"><span class="comment"># 可以看到已经挂载</span></span><br></pre></td></tr></table></figure><h2 id="安装和使用-Entware"><a href="#安装和使用-Entware" class="headerlink" title="安装和使用 Entware"></a>安装和使用 Entware</h2><p>梅林内置了一个安装命令很方便</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">entware-setup.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后会提示你选择哪个分区，就选择刚才挂载的那个</span></span><br><span class="line">···省略</span><br><span class="line">Info:  Looking <span class="keyword">for</span> available partitions...</span><br><span class="line">[1] --&gt; /tmp/mnt/sda1</span><br><span class="line">=&gt;  Please enter partition number or 0 to <span class="built_in">exit</span></span><br><span class="line">[0-1]: 1 <span class="comment"># 选1回车</span></span><br><span class="line">···省略</span><br><span class="line"><span class="comment"># 跑完之后只要不提示错误，就是安装成功了</span></span><br></pre></td></tr></table></figure><p>经过以上步骤，已经可以从 Entware 上进行下载安装包并安装到U盘上</p><p>这下可以享受丰富的软件包，还不占用内部储存空间</p><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p><a href="https://zhih.me/Padavan-entware/">在Padavan上使用entware</a></p><p><a href="https://zhih.me/LEDE-entware/">在LEDE上使用Entware</a></p><p>ONMP 是一个 web 环境快速安装脚本，适用于安装了 <a href="https://entware.net/" target="_blank" rel="noopener">Entware</a> 的路由器，目前已经在 Padavan、LEDE（openwrt）、梅林上测试成功。</p><p><a href="https://zhih.me/onmp-installation/">ONMP 安装教程</a></p><blockquote><p>本文章发表于底噪博客 <a href="https://zhih.me">https://zhih.me</a> , 转载请注明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> onmp </tag>
            
            <tag> entware </tag>
            
            <tag> 梅林 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
